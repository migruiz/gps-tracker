<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/utils/AppHidingManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/utils/AppHidingManager.kt" />
              <option name="originalContent" value="package ovh.tenjo.gpstracker.utils&#10;&#10;import android.app.admin.DevicePolicyManager&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.pm.ApplicationInfo&#10;import android.util.Log&#10;import ovh.tenjo.gpstracker.admin.DeviceAdminReceiver&#10;&#10;class AppHidingManager(private val context: Context) {&#10;&#10;    private val devicePolicyManager: DevicePolicyManager by lazy {&#10;        context.getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager&#10;    }&#10;&#10;    private val adminComponent: ComponentName by lazy {&#10;        ComponentName(context, DeviceAdminReceiver::class.java)&#10;    }&#10;&#10;    /**&#10;     * Critical system packages that should never be hidden&#10;     * MINIMAL LIST - only what's needed for GPS tracking and phone calls&#10;     */&#10;    private val criticalPackages = setOf(&#10;        // Core Android system (absolutely required)&#10;        &quot;android&quot;,&#10;        &quot;com.android.systemui&quot;,&#10;        &quot;com.android.settings&quot;,&#10;        &quot;com.android.providers.settings&quot;,&#10;&#10;        // Phone/Telephony (for calls to 2 numbers)&#10;        &quot;com.android.phone&quot;,&#10;        &quot;com.android.server.telecom&quot;,&#10;        &quot;com.android.providers.telephony&quot;,&#10;        &quot;com.android.cellbroadcastreceiver&quot;,&#10;&#10;        // Location services (for GPS)&#10;        &quot;com.android.location.fused&quot;,&#10;&#10;        // Minimal providers needed&#10;        &quot;com.android.providers.contacts&quot;,&#10;&#10;        // Shell (for debugging if needed)&#10;        &quot;com.android.shell&quot;,&#10;&#10;        // Our own app&#10;        context.packageName&#10;    )&#10;&#10;    /**&#10;     * Additional system packages that are allowed to run&#10;     * These are Android core services that cannot be hidden but are essential&#10;     */&#10;    private val allowedSystemPrefixes = setOf(&#10;        &quot;android.&quot;,&#10;        &quot;com.android.location&quot;,&#10;        &quot;com.android.server&quot;&#10;    )&#10;&#10;    fun isDeviceOwner(): Boolean {&#10;        return devicePolicyManager.isDeviceOwnerApp(context.packageName)&#10;    }&#10;&#10;    /**&#10;     * AGGRESSIVELY hide all non-critical apps to minimize CPU usage and battery drain.&#10;     * This uses a whitelist approach - everything not explicitly needed is hidden.&#10;     * Hidden apps cannot run, sync, or trigger alarms.&#10;     */&#10;    fun hideNonCriticalApps(): HideResult {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot hide apps - not device owner&quot;)&#10;            return HideResult(0, 0, &quot;Not device owner&quot;)&#10;        }&#10;&#10;        var hiddenCount = 0&#10;        var failedCount = 0&#10;        val startTime = System.currentTimeMillis()&#10;&#10;        try {&#10;            // Get all installed applications&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val packages = context.packageManager.getInstalledApplications(0)&#10;&#10;            Log.d(TAG, &quot;Found ${packages.size} installed packages - using AGGRESSIVE hiding mode&quot;)&#10;&#10;            for (appInfo in packages) {&#10;                val packageName = appInfo.packageName&#10;&#10;                // Skip critical packages (whitelist approach)&#10;                if (isCriticalPackage(packageName, appInfo)) {&#10;                    Log.d(TAG, &quot;Skipping critical package: $packageName&quot;)&#10;                    continue&#10;                }&#10;&#10;                // Try to hide the app&#10;                try {&#10;                    val isHidden = devicePolicyManager.isApplicationHidden(adminComponent, packageName)&#10;&#10;                    if (!isHidden) {&#10;                        val success = devicePolicyManager.setApplicationHidden(&#10;                            adminComponent,&#10;                            packageName,&#10;                            true&#10;                        )&#10;&#10;                        if (success) {&#10;                            hiddenCount++&#10;                            Log.d(TAG, &quot;Hidden app: $packageName&quot;)&#10;&#10;                            // Also suspend the package to ensure it can't run (API 24+)&#10;                            try {&#10;                                if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.N) {&#10;                                    devicePolicyManager.setPackagesSuspended(&#10;                                        adminComponent,&#10;                                        arrayOf(packageName),&#10;                                        true&#10;                                    )&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                // Some packages cannot be suspended&#10;                                Log.d(TAG, &quot;Could not suspend $packageName: ${e.message}&quot;)&#10;                            }&#10;                        } else {&#10;                            failedCount++&#10;                            Log.w(TAG, &quot;Failed to hide app: $packageName&quot;)&#10;                        }&#10;                    } else {&#10;                        Log.d(TAG, &quot;App already hidden: $packageName&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    failedCount++&#10;                    Log.e(TAG, &quot;Error hiding app: $packageName&quot;, e)&#10;                }&#10;            }&#10;&#10;            val duration = System.currentTimeMillis() - startTime&#10;            val message = &quot;AGGRESSIVE MODE: Hidden $hiddenCount apps, failed $failedCount, took ${duration}ms&quot;&#10;            Log.i(TAG, message)&#10;&#10;            return HideResult(hiddenCount, failedCount, message)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error in hideNonCriticalApps&quot;, e)&#10;            return HideResult(hiddenCount, failedCount, &quot;Error: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Unhide all previously hidden apps (for testing or recovery)&#10;     */&#10;    fun unhideAllApps(): HideResult {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot unhide apps - not device owner&quot;)&#10;            return HideResult(0, 0, &quot;Not device owner&quot;)&#10;        }&#10;&#10;        var unhiddenCount = 0&#10;        var failedCount = 0&#10;&#10;        try {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val packages = context.packageManager.getInstalledApplications(0)&#10;&#10;            for (appInfo in packages) {&#10;                val packageName = appInfo.packageName&#10;&#10;                try {&#10;                    val isHidden = devicePolicyManager.isApplicationHidden(adminComponent, packageName)&#10;&#10;                    if (isHidden) {&#10;                        val success = devicePolicyManager.setApplicationHidden(&#10;                            adminComponent,&#10;                            packageName,&#10;                            false&#10;                        )&#10;&#10;                        if (success) {&#10;                            unhiddenCount++&#10;                            Log.d(TAG, &quot;Unhidden app: $packageName&quot;)&#10;                        } else {&#10;                            failedCount++&#10;                            Log.w(TAG, &quot;Failed to unhide app: $packageName&quot;)&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    failedCount++&#10;                    Log.e(TAG, &quot;Error unhiding app: $packageName&quot;, e)&#10;                }&#10;            }&#10;&#10;            val message = &quot;Unhidden $unhiddenCount apps, failed $failedCount&quot;&#10;            Log.i(TAG, message)&#10;&#10;            return HideResult(unhiddenCount, failedCount, message)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error in unhideAllApps&quot;, e)&#10;            return HideResult(unhiddenCount, failedCount, &quot;Error: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if a package is critical and should not be hidden&#10;     * WHITELIST APPROACH - only explicitly allowed packages are kept&#10;     */&#10;    private fun isCriticalPackage(packageName: String, appInfo: ApplicationInfo): Boolean {&#10;        // Check if in critical whitelist&#10;        if (criticalPackages.contains(packageName)) {&#10;            return true&#10;        }&#10;&#10;        // Check if package starts with critical prefixes (very limited set)&#10;        for (prefix in allowedSystemPrefixes) {&#10;            if (packageName.startsWith(prefix)) {&#10;                return true&#10;            }&#10;        }&#10;&#10;        // Special check for system server processes (cannot be hidden)&#10;        if (packageName.startsWith(&quot;com.android.&quot;) &amp;&amp;&#10;            (packageName.contains(&quot;systemui&quot;) ||&#10;             packageName.contains(&quot;phone&quot;) ||&#10;             packageName.contains(&quot;telecom&quot;))) {&#10;            return true&#10;        }&#10;&#10;        // AGGRESSIVE: Hide ALL Google services (Play Services, Play Store, etc)&#10;        // They try to sync and use CPU constantly&#10;        if (packageName.startsWith(&quot;com.google.&quot;)) {&#10;            Log.d(TAG, &quot;HIDING Google service: $packageName&quot;)&#10;            return false&#10;        }&#10;&#10;        // AGGRESSIVE: Hide ALL manufacturer bloatware&#10;        if (packageName.startsWith(&quot;com.samsung.&quot;) ||&#10;            packageName.startsWith(&quot;com.huawei.&quot;) ||&#10;            packageName.startsWith(&quot;com.xiaomi.&quot;) ||&#10;            packageName.startsWith(&quot;com.oppo.&quot;) ||&#10;            packageName.startsWith(&quot;com.vivo.&quot;) ||&#10;            packageName.startsWith(&quot;com.oneplus.&quot;)) {&#10;            Log.d(TAG, &quot;HIDING manufacturer bloatware: $packageName&quot;)&#10;            return false&#10;        }&#10;&#10;        // AGGRESSIVE: Hide most system apps that aren't critical&#10;        if ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0) {&#10;            // It's a system app - hide unless it's in our whitelist&#10;            // This includes things like: calendar, calculator, browser, email, etc.&#10;            Log.d(TAG, &quot;HIDING non-critical system app: $packageName&quot;)&#10;            return false&#10;        }&#10;&#10;        // AGGRESSIVE: Hide ALL user-installed apps (they're not in our whitelist)&#10;        Log.d(TAG, &quot;HIDING user app: $packageName&quot;)&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Get count of currently hidden apps&#10;     */&#10;    fun getHiddenAppsCount(): Int {&#10;        if (!isDeviceOwner()) {&#10;            return -1&#10;        }&#10;&#10;        var count = 0&#10;        try {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val packages = context.packageManager.getInstalledApplications(0)&#10;&#10;            for (appInfo in packages) {&#10;                try {&#10;                    if (devicePolicyManager.isApplicationHidden(adminComponent, appInfo.packageName)) {&#10;                        count++&#10;                    }&#10;                } catch (e: Exception) {&#10;                    // Ignore&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting hidden apps count&quot;, e)&#10;        }&#10;&#10;        return count&#10;    }&#10;&#10;    data class HideResult(&#10;        val successCount: Int,&#10;        val failedCount: Int,&#10;        val message: String&#10;    )&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AppHidingManager&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.utils&#10;&#10;import android.app.admin.DevicePolicyManager&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.pm.ApplicationInfo&#10;import android.util.Log&#10;import ovh.tenjo.gpstracker.admin.DeviceAdminReceiver&#10;&#10;class AppHidingManager(private val context: Context) {&#10;&#10;    private val devicePolicyManager: DevicePolicyManager by lazy {&#10;        context.getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager&#10;    }&#10;&#10;    private val adminComponent: ComponentName by lazy {&#10;        ComponentName(context, DeviceAdminReceiver::class.java)&#10;    }&#10;&#10;    /**&#10;     * Critical system packages that should never be hidden&#10;     * OPTIMIZED FOR XIAOMI REDMI NOTE 2 - ANDROID 10&#10;     */&#10;    private val criticalPackages = setOf(&#10;        // Core Android system (absolutely required)&#10;        &quot;android&quot;,&#10;        &quot;com.android.systemui&quot;,&#10;        &quot;com.android.settings&quot;,&#10;        &quot;com.android.providers.settings&quot;,&#10;&#10;        // Phone/Telephony (for calls to 2 numbers)&#10;        &quot;com.android.phone&quot;,&#10;        &quot;com.android.server.telecom&quot;,&#10;        &quot;com.android.providers.telephony&quot;,&#10;        &quot;com.android.cellbroadcastreceiver&quot;,&#10;        &#10;        // Location services (for GPS)&#10;        &quot;com.android.location.fused&quot;,&#10;        &quot;com.android.location&quot;,&#10;        &#10;        // Minimal providers needed&#10;        &quot;com.android.providers.contacts&quot;,&#10;        &quot;com.android.providers.media&quot;,&#10;        &quot;com.android.providers.downloads&quot;,&#10;        &#10;        // Shell (for debugging if needed)&#10;        &quot;com.android.shell&quot;,&#10;        &#10;        // Input method (keyboard) - at least one needed&#10;        &quot;com.android.inputmethod.latin&quot;,&#10;        &quot;com.google.android.inputmethod.latin&quot;,&#10;        &#10;        // Package installer (needed for system stability)&#10;        &quot;com.android.packageinstaller&quot;,&#10;        &quot;com.google.android.packageinstaller&quot;,&#10;        &#10;        // XIAOMI CRITICAL SYSTEM APPS - DO NOT HIDE&#10;        &quot;com.miui.home&quot;,                    // MIUI launcher - critical!&#10;        &quot;com.miui.systemui&quot;,                // MIUI system UI&#10;        &quot;com.android.incallui&quot;,             // Call UI&#10;        &quot;com.miui.securitycenter&quot;,          // MIUI security (handles permissions)&#10;        &quot;com.xiaomi.finddevice&quot;,            // Find device (system service)&#10;        &quot;com.miui.powerkeeper&quot;,             // Power management (critical for battery)&#10;        &quot;com.miui.notification&quot;,            // Notification system&#10;        &quot;com.android.mms&quot;,                  // SMS/MMS (for emergency)&#10;        &quot;com.android.contacts&quot;,             // Contacts (needed for calls)&#10;        &quot;com.miui.core&quot;,                    // MIUI core services&#10;        &quot;com.xiaomi.market&quot;,                // May be required by system&#10;        &quot;com.miui.analytics&quot;,               // System analytics&#10;        &quot;com.miui.daemon&quot;,                  // MIUI daemon&#10;        &quot;com.xiaomi.xmsf&quot;,                  // Xiaomi message service framework&#10;        &#10;        // Our own app&#10;        context.packageName&#10;    )&#10;&#10;    /**&#10;     * Additional system packages that are allowed to run&#10;     * These are Android core services that cannot be hidden but are essential&#10;     */&#10;    private val allowedSystemPrefixes = setOf(&#10;        &quot;android.&quot;,&#10;        &quot;com.android.location&quot;,&#10;        &quot;com.android.server&quot;,&#10;        &quot;com.qualcomm.&quot;,                    // Qualcomm system services (Xiaomi uses Qualcomm chips)&#10;        &quot;com.qti.&quot;,                         // Qualcomm technologies&#10;        &quot;org.codeaurora.&quot;                   // Code Aurora (Qualcomm)&#10;    )&#10;    &#10;    /**&#10;     * Xiaomi bloatware that is SAFE to hide&#10;     * These are confirmed non-critical apps that won't break the system&#10;     */&#10;    private val xiaomiSafeToHide = setOf(&#10;        &quot;com.xiaomi.gamecenter&quot;,&#10;        &quot;com.xiaomi.glgm&quot;,&#10;        &quot;com.xiaomi.payment&quot;,&#10;        &quot;com.xiaomi.scanner&quot;,&#10;        &quot;com.xiaomi.shop&quot;,&#10;        &quot;com.mi.android.globalminusscreen&quot;,&#10;        &quot;com.miui.gallery&quot;,&#10;        &quot;com.miui.video&quot;,&#10;        &quot;com.miui.player&quot;,&#10;        &quot;com.miui.notes&quot;,&#10;        &quot;com.miui.calculator&quot;,&#10;        &quot;com.miui.weather2&quot;,&#10;        &quot;com.miui.compass&quot;,&#10;        &quot;com.miui.fm&quot;,&#10;        &quot;com.android.browser&quot;,&#10;        &quot;com.android.chrome&quot;,&#10;        &quot;com.miui.bugreport&quot;,&#10;        &quot;com.miui.yellowpage&quot;&#10;    )&#10;&#10;    fun isDeviceOwner(): Boolean {&#10;        return devicePolicyManager.isDeviceOwnerApp(context.packageName)&#10;    }&#10;&#10;    /**&#10;     * AGGRESSIVELY hide all non-critical apps to minimize CPU usage and battery drain.&#10;     * This uses a whitelist approach - everything not explicitly needed is hidden.&#10;     * Hidden apps cannot run, sync, or trigger alarms.&#10;     */&#10;    fun hideNonCriticalApps(): HideResult {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot hide apps - not device owner&quot;)&#10;            return HideResult(0, 0, &quot;Not device owner&quot;)&#10;        }&#10;&#10;        var hiddenCount = 0&#10;        var failedCount = 0&#10;        val startTime = System.currentTimeMillis()&#10;&#10;        try {&#10;            // Get all installed applications&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val packages = context.packageManager.getInstalledApplications(0)&#10;&#10;            Log.d(TAG, &quot;Found ${packages.size} installed packages - using AGGRESSIVE hiding mode&quot;)&#10;&#10;            for (appInfo in packages) {&#10;                val packageName = appInfo.packageName&#10;&#10;                // Skip critical packages (whitelist approach)&#10;                if (isCriticalPackage(packageName, appInfo)) {&#10;                    Log.d(TAG, &quot;Skipping critical package: $packageName&quot;)&#10;                    continue&#10;                }&#10;&#10;                // Try to hide the app&#10;                try {&#10;                    val isHidden = devicePolicyManager.isApplicationHidden(adminComponent, packageName)&#10;&#10;                    if (!isHidden) {&#10;                        val success = devicePolicyManager.setApplicationHidden(&#10;                            adminComponent,&#10;                            packageName,&#10;                            true&#10;                        )&#10;&#10;                        if (success) {&#10;                            hiddenCount++&#10;                            Log.d(TAG, &quot;Hidden app: $packageName&quot;)&#10;&#10;                            // Also suspend the package to ensure it can't run (API 24+)&#10;                            try {&#10;                                if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.N) {&#10;                                    devicePolicyManager.setPackagesSuspended(&#10;                                        adminComponent,&#10;                                        arrayOf(packageName),&#10;                                        true&#10;                                    )&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                // Some packages cannot be suspended&#10;                                Log.d(TAG, &quot;Could not suspend $packageName: ${e.message}&quot;)&#10;                            }&#10;                        } else {&#10;                            failedCount++&#10;                            Log.w(TAG, &quot;Failed to hide app: $packageName&quot;)&#10;                        }&#10;                    } else {&#10;                        Log.d(TAG, &quot;App already hidden: $packageName&quot;)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    failedCount++&#10;                    Log.e(TAG, &quot;Error hiding app: $packageName&quot;, e)&#10;                }&#10;            }&#10;&#10;            val duration = System.currentTimeMillis() - startTime&#10;            val message = &quot;AGGRESSIVE MODE: Hidden $hiddenCount apps, failed $failedCount, took ${duration}ms&quot;&#10;            Log.i(TAG, message)&#10;&#10;            return HideResult(hiddenCount, failedCount, message)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error in hideNonCriticalApps&quot;, e)&#10;            return HideResult(hiddenCount, failedCount, &quot;Error: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Unhide all previously hidden apps (for testing or recovery)&#10;     */&#10;    fun unhideAllApps(): HideResult {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot unhide apps - not device owner&quot;)&#10;            return HideResult(0, 0, &quot;Not device owner&quot;)&#10;        }&#10;&#10;        var unhiddenCount = 0&#10;        var failedCount = 0&#10;&#10;        try {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val packages = context.packageManager.getInstalledApplications(0)&#10;&#10;            for (appInfo in packages) {&#10;                val packageName = appInfo.packageName&#10;&#10;                try {&#10;                    val isHidden = devicePolicyManager.isApplicationHidden(adminComponent, packageName)&#10;&#10;                    if (isHidden) {&#10;                        val success = devicePolicyManager.setApplicationHidden(&#10;                            adminComponent,&#10;                            packageName,&#10;                            false&#10;                        )&#10;&#10;                        if (success) {&#10;                            unhiddenCount++&#10;                            Log.d(TAG, &quot;Unhidden app: $packageName&quot;)&#10;                        } else {&#10;                            failedCount++&#10;                            Log.w(TAG, &quot;Failed to unhide app: $packageName&quot;)&#10;                        }&#10;                    }&#10;                } catch (e: Exception) {&#10;                    failedCount++&#10;                    Log.e(TAG, &quot;Error unhiding app: $packageName&quot;, e)&#10;                }&#10;            }&#10;&#10;            val message = &quot;Unhidden $unhiddenCount apps, failed $failedCount&quot;&#10;            Log.i(TAG, message)&#10;&#10;            return HideResult(unhiddenCount, failedCount, message)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error in unhideAllApps&quot;, e)&#10;            return HideResult(unhiddenCount, failedCount, &quot;Error: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Check if a package is critical and should not be hidden&#10;     * XIAOMI-SAFE APPROACH - protects critical MIUI system components&#10;     */&#10;    private fun isCriticalPackage(packageName: String, appInfo: ApplicationInfo): Boolean {&#10;        // Check if in critical whitelist&#10;        if (criticalPackages.contains(packageName)) {&#10;            return true&#10;        }&#10;&#10;        // Check if package starts with critical prefixes (very limited set)&#10;        for (prefix in allowedSystemPrefixes) {&#10;            if (packageName.startsWith(prefix)) {&#10;                return true&#10;            }&#10;        }&#10;&#10;        // Special check for Android system processes (cannot be hidden)&#10;        if (packageName.startsWith(&quot;com.android.&quot;) &amp;&amp;&#10;            (packageName.contains(&quot;systemui&quot;) ||&#10;             packageName.contains(&quot;phone&quot;) ||&#10;             packageName.contains(&quot;telecom&quot;) ||&#10;             packageName.contains(&quot;incallui&quot;) ||&#10;             packageName.contains(&quot;mms&quot;) ||&#10;             packageName.contains(&quot;contacts&quot;))) {&#10;            return true&#10;        }&#10;        &#10;        // XIAOMI-SPECIFIC: Keep critical MIUI system components&#10;        if (packageName.startsWith(&quot;com.miui.&quot;) || packageName.startsWith(&quot;com.xiaomi.&quot;)) {&#10;            // Check if it's safe to hide&#10;            if (xiaomiSafeToHide.contains(packageName)) {&#10;                Log.d(TAG, &quot;HIDING safe Xiaomi bloatware: $packageName&quot;)&#10;                return false&#10;            }&#10;            &#10;            // Keep all other MIUI/Xiaomi system apps to prevent instability&#10;            Log.d(TAG, &quot;KEEPING Xiaomi system app (safety): $packageName&quot;)&#10;            return true&#10;        }&#10;&#10;        // AGGRESSIVE: Hide ALL Google services (Play Services, Play Store, etc)&#10;        // They try to sync and use CPU constantly&#10;        if (packageName.startsWith(&quot;com.google.&quot;)) {&#10;            Log.d(TAG, &quot;HIDING Google service: $packageName&quot;)&#10;            return false&#10;        }&#10;&#10;        // AGGRESSIVE: Hide other manufacturer bloatware (not Xiaomi)&#10;        if (packageName.startsWith(&quot;com.samsung.&quot;) ||&#10;            packageName.startsWith(&quot;com.huawei.&quot;) ||&#10;            packageName.startsWith(&quot;com.oppo.&quot;) ||&#10;            packageName.startsWith(&quot;com.vivo.&quot;) ||&#10;            packageName.startsWith(&quot;com.oneplus.&quot;)) {&#10;            Log.d(TAG, &quot;HIDING other manufacturer bloatware: $packageName&quot;)&#10;            return false&#10;        }&#10;&#10;        // CONSERVATIVE: For system apps not in whitelist, be cautious&#10;        if ((appInfo.flags and ApplicationInfo.FLAG_SYSTEM) != 0) {&#10;            // It's a system app - hide only if we're sure it's safe&#10;            // Keep most system apps to prevent instability on Xiaomi&#10;            Log.d(TAG, &quot;KEEPING system app (conservative): $packageName&quot;)&#10;            return true&#10;        }&#10;&#10;        // AGGRESSIVE: Hide ALL user-installed apps (they're not in our whitelist)&#10;        Log.d(TAG, &quot;HIDING user-installed app: $packageName&quot;)&#10;        return false&#10;    }&#10;&#10;    /**&#10;     * Get count of currently hidden apps&#10;     */&#10;    fun getHiddenAppsCount(): Int {&#10;        if (!isDeviceOwner()) {&#10;            return -1&#10;        }&#10;&#10;        var count = 0&#10;        try {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val packages = context.packageManager.getInstalledApplications(0)&#10;&#10;            for (appInfo in packages) {&#10;                try {&#10;                    if (devicePolicyManager.isApplicationHidden(adminComponent, appInfo.packageName)) {&#10;                        count++&#10;                    }&#10;                } catch (e: Exception) {&#10;                    // Ignore&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error getting hidden apps count&quot;, e)&#10;        }&#10;&#10;        return count&#10;    }&#10;&#10;    data class HideResult(&#10;        val successCount: Int,&#10;        val failedCount: Int,&#10;        val message: String&#10;    )&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AppHidingManager&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/utils/ConnectivityManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/utils/ConnectivityManager.kt" />
              <option name="originalContent" value="package ovh.tenjo.gpstracker.utils&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.admin.DevicePolicyManager&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.net.wifi.WifiManager&#10;import android.os.Build&#10;import android.provider.Settings&#10;import android.util.Log&#10;import ovh.tenjo.gpstracker.admin.DeviceAdminReceiver&#10;import java.lang.reflect.Method&#10;&#10;class ConnectivityManager(private val context: Context) {&#10;&#10;    private val devicePolicyManager: DevicePolicyManager by lazy {&#10;        context.getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager&#10;    }&#10;&#10;    private val wifiManager: WifiManager by lazy {&#10;        context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager&#10;    }&#10;&#10;    private val connectivityManager: android.net.ConnectivityManager by lazy {&#10;        context.getSystemService(Context.CONNECTIVITY_SERVICE) as android.net.ConnectivityManager&#10;    }&#10;&#10;    private val adminComponent: ComponentName by lazy {&#10;        ComponentName(context, DeviceAdminReceiver::class.java)&#10;    }&#10;&#10;    fun isDeviceOwner(): Boolean {&#10;        return devicePolicyManager.isDeviceOwnerApp(context.packageName)&#10;    }&#10;&#10;    fun restrictBackgroundData() {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot restrict background data - not device owner&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // Get all installed packages and restrict their background data&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val packages = context.packageManager.getInstalledApplications(0)&#10;&#10;            var restrictedCount = 0&#10;            for (packageInfo in packages) {&#10;                if (packageInfo.packageName != context.packageName) {&#10;                    try {&#10;                        // Restrict background data&#10;                        devicePolicyManager.setApplicationRestrictions(&#10;                            adminComponent,&#10;                            packageInfo.packageName,&#10;                            android.os.Bundle().apply {&#10;                                putBoolean(&quot;background_data&quot;, false)&#10;                            }&#10;                        )&#10;&#10;                        // Also add to restricted background apps list (API 21+)&#10;                        try {&#10;                            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                                devicePolicyManager.addUserRestriction(&#10;                                    adminComponent,&#10;                                    &quot;no_config_vpn&quot;&#10;                                )&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            // Ignore if already set&#10;                        }&#10;&#10;                        restrictedCount++&#10;                    } catch (_: Exception) {&#10;                        // Some system packages may not allow restrictions&#10;                    }&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Restricted background data for $restrictedCount apps&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error restricting background data&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Apply aggressive power and performance restrictions to minimize CPU usage&#10;     * This should be called once when device owner is set up&#10;     */&#10;    fun applyAggressivePowerRestrictions() {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot apply power restrictions - not device owner&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // Disable automatic time zone (saves CPU from network checks)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                try {&#10;                    devicePolicyManager.setAutoTimeRequired(adminComponent, false)&#10;                    Log.d(TAG, &quot;Disabled automatic time updates&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.d(TAG, &quot;Could not disable auto time: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            // Set global settings to minimize background activity&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                try {&#10;                    // Disable location mode for other apps (we use GPS directly)&#10;                    devicePolicyManager.setGlobalSetting(&#10;                        adminComponent,&#10;                        Settings.Global.DEVELOPMENT_SETTINGS_ENABLED,&#10;                        &quot;0&quot;&#10;                    )&#10;                    Log.d(TAG, &quot;Applied global power settings&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.d(TAG, &quot;Could not set global settings: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            // Add user restrictions to prevent background activities&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                val restrictions = listOf(&#10;                    &quot;no_modify_accounts&quot;,      // Prevent apps from syncing accounts&#10;                    &quot;no_config_credentials&quot;,    // Prevent credential changes&#10;                    &quot;no_install_apps&quot;,          // Prevent app installations&#10;                    &quot;no_uninstall_apps&quot;,        // Prevent app uninstalls&#10;                    &quot;no_share_location&quot;,        // Prevent other apps from accessing location&#10;                    &quot;no_config_bluetooth&quot;,      // Prevent bluetooth changes (saves power)&#10;                    &quot;no_config_wifi&quot;            // Prevent wifi changes&#10;                )&#10;&#10;                for (restriction in restrictions) {&#10;                    try {&#10;                        devicePolicyManager.addUserRestriction(adminComponent, restriction)&#10;                        Log.d(TAG, &quot;Added restriction: $restriction&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.d(TAG, &quot;Could not add restriction $restriction: ${e.message}&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Log.i(TAG, &quot;Applied aggressive power restrictions successfully&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error applying power restrictions&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun enableKioskMode() {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot enable kiosk mode - not device owner&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // Set this app as lock task package&#10;            devicePolicyManager.setLockTaskPackages(&#10;                adminComponent,&#10;                arrayOf(context.packageName)&#10;            )&#10;&#10;            // Disable keyguard (API 23+)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                devicePolicyManager.setKeyguardDisabled(adminComponent, true)&#10;            }&#10;&#10;            // Disable status bar (API 23+)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                devicePolicyManager.setStatusBarDisabled(adminComponent, true)&#10;            }&#10;&#10;            Log.d(TAG, &quot;Kiosk mode enabled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error enabling kiosk mode&quot;, e)&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ConnectivityManager&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.utils&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.admin.DevicePolicyManager&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.net.wifi.WifiManager&#10;import android.os.Build&#10;import android.provider.Settings&#10;import android.util.Log&#10;import ovh.tenjo.gpstracker.admin.DeviceAdminReceiver&#10;import java.lang.reflect.Method&#10;&#10;class ConnectivityManager(private val context: Context) {&#10;&#10;    private val devicePolicyManager: DevicePolicyManager by lazy {&#10;        context.getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager&#10;    }&#10;&#10;    private val wifiManager: WifiManager by lazy {&#10;        context.applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager&#10;    }&#10;&#10;    private val connectivityManager: android.net.ConnectivityManager by lazy {&#10;        context.getSystemService(Context.CONNECTIVITY_SERVICE) as android.net.ConnectivityManager&#10;    }&#10;&#10;    private val adminComponent: ComponentName by lazy {&#10;        ComponentName(context, DeviceAdminReceiver::class.java)&#10;    }&#10;&#10;    fun isDeviceOwner(): Boolean {&#10;        return devicePolicyManager.isDeviceOwnerApp(context.packageName)&#10;    }&#10;&#10;    fun restrictBackgroundData() {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot restrict background data - not device owner&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // Get all installed packages and restrict their background data&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val packages = context.packageManager.getInstalledApplications(0)&#10;&#10;            var restrictedCount = 0&#10;            for (packageInfo in packages) {&#10;                if (packageInfo.packageName != context.packageName) {&#10;                    try {&#10;                        // Restrict background data&#10;                        devicePolicyManager.setApplicationRestrictions(&#10;                            adminComponent,&#10;                            packageInfo.packageName,&#10;                            android.os.Bundle().apply {&#10;                                putBoolean(&quot;background_data&quot;, false)&#10;                            }&#10;                        )&#10;&#10;                        // Also add to restricted background apps list (API 21+)&#10;                        try {&#10;                            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                                devicePolicyManager.addUserRestriction(&#10;                                    adminComponent,&#10;                                    &quot;no_config_vpn&quot;&#10;                                )&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            // Ignore if already set&#10;                        }&#10;&#10;                        restrictedCount++&#10;                    } catch (_: Exception) {&#10;                        // Some system packages may not allow restrictions&#10;                    }&#10;                }&#10;            }&#10;            Log.d(TAG, &quot;Restricted background data for $restrictedCount apps&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error restricting background data&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Apply aggressive power and performance restrictions to minimize CPU usage&#10;     * XIAOMI-SAFE: Conservative approach to avoid system instability&#10;     */&#10;    fun applyAggressivePowerRestrictions() {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot apply power restrictions - not device owner&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // Disable automatic time zone (saves CPU from network checks)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                try {&#10;                    devicePolicyManager.setAutoTimeRequired(adminComponent, false)&#10;                    Log.d(TAG, &quot;Disabled automatic time updates&quot;)&#10;                } catch (e: Exception) {&#10;                    Log.d(TAG, &quot;Could not disable auto time: ${e.message}&quot;)&#10;                }&#10;            }&#10;&#10;            // Add CONSERVATIVE user restrictions to prevent background activities&#10;            // Only add restrictions that won't break Xiaomi system functionality&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {&#10;                val safeRestrictions = listOf(&#10;                    &quot;no_install_apps&quot;,          // Prevent app installations&#10;                    &quot;no_uninstall_apps&quot;         // Prevent app uninstalls&#10;                    // NOTE: Removed other restrictions as they may interfere with MIUI&#10;                    // Xiaomi's MIUI has many system services that need access to:&#10;                    // - Accounts (MIUI cloud, etc.)&#10;                    // - Location (Find Device, etc.)&#10;                    // - Bluetooth/WiFi (system optimization)&#10;                )&#10;                &#10;                for (restriction in safeRestrictions) {&#10;                    try {&#10;                        devicePolicyManager.addUserRestriction(adminComponent, restriction)&#10;                        Log.d(TAG, &quot;Added restriction: $restriction&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.d(TAG, &quot;Could not add restriction $restriction: ${e.message}&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Log.i(TAG, &quot;Applied XIAOMI-SAFE power restrictions successfully&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error applying power restrictions&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun enableKioskMode() {&#10;        if (!isDeviceOwner()) {&#10;            Log.w(TAG, &quot;Cannot enable kiosk mode - not device owner&quot;)&#10;            return&#10;        }&#10;&#10;        try {&#10;            // Set this app as lock task package&#10;            devicePolicyManager.setLockTaskPackages(&#10;                adminComponent,&#10;                arrayOf(context.packageName)&#10;            )&#10;&#10;            // Disable keyguard (API 23+)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                devicePolicyManager.setKeyguardDisabled(adminComponent, true)&#10;            }&#10;&#10;            // Disable status bar (API 23+)&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                devicePolicyManager.setStatusBarDisabled(adminComponent, true)&#10;            }&#10;&#10;            Log.d(TAG, &quot;Kiosk mode enabled&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error enabling kiosk mode&quot;, e)&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ConnectivityManager&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>