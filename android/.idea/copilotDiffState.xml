<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/MainActivity.kt" />
              <option name="originalContent" value="package ovh.tenjo.gpstracker&#10;&#10;import android.Manifest&#10;import android.app.ActivityManager&#10;import android.content.*&#10;import android.content.pm.PackageManager&#10;import android.net.VpnService&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.ContextCompat&#10;import ovh.tenjo.gpstracker.config.AppConfig&#10;import ovh.tenjo.gpstracker.model.AppState&#10;import ovh.tenjo.gpstracker.service.GpsTrackingService&#10;import ovh.tenjo.gpstracker.ui.theme.GPSTrackerTheme&#10;import ovh.tenjo.gpstracker.location.SinkholeVpnService&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private var trackingService: GpsTrackingService? = null&#10;    private var serviceBound = false&#10;&#10;    private var stateInfo by mutableStateOf&lt;GpsTrackingService.StateInfo?&gt;(null)&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            val binder = service as GpsTrackingService.LocalBinder&#10;            trackingService = binder.getService()&#10;            serviceBound = true&#10;            updateStateInfo()&#10;        }&#10;&#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            trackingService = null&#10;            serviceBound = false&#10;        }&#10;    }&#10;&#10;    private val stateUpdateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            updateStateInfo()&#10;        }&#10;    }&#10;&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val allGranted = permissions.values.all { it }&#10;        if (allGranted) {&#10;            startTrackingService()&#10;        } else {&#10;            Log.e(TAG, &quot;Some permissions not granted&quot;)&#10;        }&#10;    }&#10;&#10;    private val vpnPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        if (result.resultCode == RESULT_OK) {&#10;            // VPN permission granted, start the service&#10;            startVpnServiceInternal()&#10;        } else {&#10;            // Permission not granted, show a message to the user&#10;            Log.e(TAG, &quot;VPN permission not granted&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Request permissions&#10;        checkAndRequestPermissions()&#10;&#10;        // Register broadcast receiver&#10;        val filter = IntentFilter(GpsTrackingService.ACTION_STATE_UPDATE)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            registerReceiver(stateUpdateReceiver, filter, RECEIVER_NOT_EXPORTED)&#10;        } else {&#10;            @Suppress(&quot;UnspecifiedRegisterReceiverFlag&quot;)&#10;            registerReceiver(stateUpdateReceiver, filter)&#10;        }&#10;&#10;        setContent {&#10;            GPSTrackerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    DebugUI(stateInfo, this@MainActivity)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Start lock task mode if device owner&#10;        try {&#10;            startLockTask()&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Could not start lock task mode&quot;, e)&#10;        }&#10;    }&#10;&#10;    override fun onStart() {&#10;        super.onStart()&#10;        // Bind to service&#10;        val intent = Intent(this, GpsTrackingService::class.java)&#10;        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;&#10;    override fun onStop() {&#10;        super.onStop()&#10;        if (serviceBound) {&#10;            unbindService(serviceConnection)&#10;            serviceBound = false&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            unregisterReceiver(stateUpdateReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error unregistering receiver&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun checkAndRequestPermissions() {&#10;        val permissions = mutableListOf(&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION,&#10;            Manifest.permission.INTERNET,&#10;            Manifest.permission.ACCESS_NETWORK_STATE,&#10;            Manifest.permission.CHANGE_NETWORK_STATE,&#10;            Manifest.permission.ACCESS_WIFI_STATE,&#10;            Manifest.permission.CHANGE_WIFI_STATE&#10;        )&#10;&#10;        // Add background location for Android 10+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            permissions.add(Manifest.permission.ACCESS_BACKGROUND_LOCATION)&#10;        }&#10;        &#10;        // Add foreground service location for Android 14+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {&#10;            permissions.add(Manifest.permission.FOREGROUND_SERVICE_LOCATION)&#10;        }&#10;&#10;        val permissionsToRequest = permissions.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsToRequest.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Requesting permissions: $permissionsToRequest&quot;)&#10;            permissionLauncher.launch(permissionsToRequest.toTypedArray())&#10;        } else {&#10;            Log.d(TAG, &quot;All permissions already granted&quot;)&#10;            startTrackingService()&#10;        }&#10;    }&#10;&#10;    private fun startTrackingService() {&#10;        if (!isServiceRunning(GpsTrackingService::class.java)) {&#10;            val intent = Intent(this, GpsTrackingService::class.java)&#10;            ContextCompat.startForegroundService(this, intent)&#10;            Log.d(TAG, &quot;Started tracking service&quot;)&#10;        }&#10;    }&#10;&#10;    private fun isServiceRunning(serviceClass: Class&lt;*&gt;): Boolean {&#10;        val manager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        return manager.getRunningServices(Integer.MAX_VALUE)&#10;            .any { it.service.className == serviceClass.name }&#10;    }&#10;&#10;    private fun updateStateInfo() {&#10;        stateInfo = trackingService?.getStateInfo()&#10;    }&#10;&#10;    private fun showPermissionError() {&#10;        // Update UI to show error - for now just log&#10;        Log.e(TAG, &quot;Cannot start tracking - permissions not granted&quot;)&#10;        // You could show a dialog or snackbar here&#10;    }&#10;&#10;    public fun startSinkholeVpn() {&#10;        // Check if VPN permission is already granted&#10;        val prepareIntent = VpnService.prepare(this)&#10;        if (prepareIntent != null) {&#10;            // Need to request VPN permission&#10;            Log.d(TAG, &quot;Requesting VPN permission&quot;)&#10;            vpnPermissionLauncher.launch(prepareIntent)&#10;        } else {&#10;            // Permission already granted, start VPN directly&#10;            Log.d(TAG, &quot;VPN permission already granted&quot;)&#10;            startVpnServiceInternal()&#10;        }&#10;    }&#10;&#10;    private fun startVpnServiceInternal() {&#10;        val intent = Intent(this, SinkholeVpnService::class.java)&#10;        try {&#10;            ContextCompat.startForegroundService(this, intent)&#10;            Log.d(TAG, &quot;Started Sinkhole VPN service&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to start Sinkhole VPN service&quot;, e)&#10;        }&#10;    }&#10;&#10;    public fun stopSinkholeVpn() {&#10;        val intent = Intent(this, SinkholeVpnService::class.java)&#10;        stopService(intent)&#10;        Log.d(TAG, &quot;Stopped Sinkhole VPN service&quot;)&#10;    }&#10;&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MainActivity&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DebugUI(stateInfo: GpsTrackingService.StateInfo?, context: Context) {&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;GPS Tracker Debug UI&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Current Time&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Current Time&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;                        .format(Date()),&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;&#10;        // App State&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Current State&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;&#10;                val stateColor = when (stateInfo?.state) {&#10;                    AppState.IDLE -&gt; Color.Gray&#10;                    AppState.AWAKE -&gt; Color.Green&#10;                    AppState.BATTERY_CHECK -&gt; Color.Yellow&#10;                    null -&gt; Color.Red&#10;                }&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(top = 8.dp)&#10;                        .background(stateColor)&#10;                        .padding(8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = stateInfo?.state?.name ?: &quot;UNKNOWN&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Device Owner Status&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Device Owner Status&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = if (stateInfo?.isDeviceOwner == true) &quot;✓ Device Owner&quot; else &quot;✗ Not Device Owner&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = if (stateInfo?.isDeviceOwner == true) Color.Green else Color.Red&#10;                )&#10;&#10;                // Show hidden apps count if device owner&#10;                if (stateInfo?.isDeviceOwner == true) {&#10;                    Text(&#10;                        text = &quot;Hidden Apps: ${stateInfo.hiddenAppsCount}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;System Optimized for Battery&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.Gray&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Battery Info&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Battery&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = &quot;Level: ${stateInfo?.batteryLevel ?: &quot;N/A&quot;}%&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;                Text(&#10;                    text = &quot;Charging: ${if (stateInfo?.isCharging == true) &quot;Yes&quot; else &quot;No&quot;}&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;&#10;        // HTTP Info (only show when awake)&#10;        if (stateInfo?.state == AppState.AWAKE) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;            ) {&#10;                Column(modifier = Modifier.padding(16.dp)) {&#10;                    Text(&#10;                        text = &quot;HTTP API Connection&quot;,&#10;                        style = MaterialTheme.typography.titleMedium&#10;                    )&#10;&#10;                    Row(&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(16.dp)&#10;                                .background(&#10;                                    if (stateInfo?.httpConnected == true) Color.Green else Color.Red&#10;                                )&#10;                        )&#10;                        Text(&#10;                            text = if (stateInfo?.httpConnected == true) &quot;Ready&quot; else &quot;Not Ready&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Endpoint: ${stateInfo?.apiEndpoint ?: &quot;N/A&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Device ID: ${stateInfo?.deviceId ?: &quot;N/A&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;&#10;            // GPS Tracking Info&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;            ) {&#10;                Column(modifier = Modifier.padding(16.dp)) {&#10;                    Text(&#10;                        text = &quot;GPS Tracking&quot;,&#10;                        style = MaterialTheme.typography.titleMedium&#10;                    )&#10;&#10;                    Row(&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(16.dp)&#10;                                .background(&#10;                                    if (stateInfo?.gpsTracking == true) Color.Green else Color.Red&#10;                                )&#10;                        )&#10;                        Text(&#10;                            text = if (stateInfo?.gpsTracking == true) &quot;Active&quot; else &quot;Inactive&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Update interval: ${AppConfig.GPS_UPDATE_INTERVAL_MS / 1000}s&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Awake Time Slots&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Configured Awake Time Slots&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;&#10;                AppConfig.AWAKE_TIME_SLOTS.forEach { timeSlot -&gt;&#10;                    Text(&#10;                        text = &quot;• $timeSlot&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // System Info&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;System Information&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = &quot;Battery check: Every ${AppConfig.BATTERY_CHECK_INTERVAL_MS / 60000} minutes&quot;,&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;                Text(&#10;                    text = &quot;Battery threshold: ${AppConfig.BATTERY_LOW_THRESHOLD}%&quot;,&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;            }&#10;        }&#10;&#10;        // Sinkhole VPN Control&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Internet Sinkhole (VPN)&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = &quot;Block all traffic except this app&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    modifier = Modifier.padding(top = 4.dp, bottom = 12.dp)&#10;                )&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 8.dp),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Button(&#10;                        onClick = {&#10;                            (context as? MainActivity)?.startSinkholeVpn()&#10;                        },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Start VPN&quot;)&#10;                    }&#10;                    Button(&#10;                        onClick = {&#10;                            (context as? MainActivity)?.stopSinkholeVpn()&#10;                        },&#10;                        modifier = Modifier.weight(1f),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.error&#10;                        )&#10;                    ) {&#10;                        Text(&quot;Stop VPN&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker&#10;&#10;import android.Manifest&#10;import android.app.ActivityManager&#10;import android.content.*&#10;import android.content.pm.PackageManager&#10;import android.net.VpnService&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.ContextCompat&#10;import ovh.tenjo.gpstracker.config.AppConfig&#10;import ovh.tenjo.gpstracker.model.AppState&#10;import ovh.tenjo.gpstracker.service.GpsTrackingService&#10;import ovh.tenjo.gpstracker.ui.theme.GPSTrackerTheme&#10;import ovh.tenjo.gpstracker.location.SinkholeVpnService&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class MainActivity : ComponentActivity() {&#10;&#10;    private var trackingService: GpsTrackingService? = null&#10;    private var serviceBound = false&#10;&#10;    private var stateInfo by mutableStateOf&lt;GpsTrackingService.StateInfo?&gt;(null)&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            val binder = service as GpsTrackingService.LocalBinder&#10;            trackingService = binder.getService()&#10;            serviceBound = true&#10;            updateStateInfo()&#10;        }&#10;&#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            trackingService = null&#10;            serviceBound = false&#10;        }&#10;    }&#10;&#10;    private val stateUpdateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            updateStateInfo()&#10;        }&#10;    }&#10;&#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val allGranted = permissions.values.all { it }&#10;        if (allGranted) {&#10;            startTrackingService()&#10;        } else {&#10;            Log.e(TAG, &quot;Some permissions not granted&quot;)&#10;        }&#10;    }&#10;&#10;    private val vpnPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        if (result.resultCode == RESULT_OK) {&#10;            // VPN permission granted, start the service&#10;            startVpnServiceInternal()&#10;        } else {&#10;            // Permission not granted, show a message to the user&#10;            Log.e(TAG, &quot;VPN permission not granted&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Request permissions&#10;        checkAndRequestPermissions()&#10;&#10;        // Register broadcast receiver&#10;        val filter = IntentFilter(GpsTrackingService.ACTION_STATE_UPDATE)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            registerReceiver(stateUpdateReceiver, filter, RECEIVER_NOT_EXPORTED)&#10;        } else {&#10;            @Suppress(&quot;UnspecifiedRegisterReceiverFlag&quot;)&#10;            registerReceiver(stateUpdateReceiver, filter)&#10;        }&#10;&#10;        setContent {&#10;            GPSTrackerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    DebugUI(stateInfo, this@MainActivity)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Start lock task mode if device owner&#10;        try {&#10;            startLockTask()&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Could not start lock task mode&quot;, e)&#10;        }&#10;    }&#10;&#10;    override fun onStart() {&#10;        super.onStart()&#10;        // Bind to service&#10;        val intent = Intent(this, GpsTrackingService::class.java)&#10;        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;&#10;    override fun onStop() {&#10;        super.onStop()&#10;        if (serviceBound) {&#10;            unbindService(serviceConnection)&#10;            serviceBound = false&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            unregisterReceiver(stateUpdateReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error unregistering receiver&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun checkAndRequestPermissions() {&#10;        val permissions = mutableListOf(&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION,&#10;            Manifest.permission.INTERNET,&#10;            Manifest.permission.ACCESS_NETWORK_STATE,&#10;            Manifest.permission.CHANGE_NETWORK_STATE,&#10;            Manifest.permission.ACCESS_WIFI_STATE,&#10;            Manifest.permission.CHANGE_WIFI_STATE&#10;        )&#10;&#10;        // Add background location for Android 10+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;            permissions.add(Manifest.permission.ACCESS_BACKGROUND_LOCATION)&#10;        }&#10;        &#10;        // Add foreground service location for Android 14+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {&#10;            permissions.add(Manifest.permission.FOREGROUND_SERVICE_LOCATION)&#10;        }&#10;&#10;        val permissionsToRequest = permissions.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;&#10;        if (permissionsToRequest.isNotEmpty()) {&#10;            Log.d(TAG, &quot;Requesting permissions: $permissionsToRequest&quot;)&#10;            permissionLauncher.launch(permissionsToRequest.toTypedArray())&#10;        } else {&#10;            Log.d(TAG, &quot;All permissions already granted&quot;)&#10;            startTrackingService()&#10;        }&#10;    }&#10;&#10;    private fun startTrackingService() {&#10;        if (!isServiceRunning(GpsTrackingService::class.java)) {&#10;            val intent = Intent(this, GpsTrackingService::class.java)&#10;            ContextCompat.startForegroundService(this, intent)&#10;            Log.d(TAG, &quot;Started tracking service&quot;)&#10;        }&#10;    }&#10;&#10;    private fun isServiceRunning(serviceClass: Class&lt;*&gt;): Boolean {&#10;        val manager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        return manager.getRunningServices(Integer.MAX_VALUE)&#10;            .any { it.service.className == serviceClass.name }&#10;    }&#10;&#10;    private fun updateStateInfo() {&#10;        stateInfo = trackingService?.getStateInfo()&#10;    }&#10;&#10;    private fun showPermissionError() {&#10;        // Update UI to show error - for now just log&#10;        Log.e(TAG, &quot;Cannot start tracking - permissions not granted&quot;)&#10;        // You could show a dialog or snackbar here&#10;    }&#10;&#10;    public fun startSinkholeVpn() {&#10;        try {&#10;            // Check if VPN permission is already granted&#10;            // For Device Owner apps, this will return null (permission already granted)&#10;            val prepareIntent = VpnService.prepare(this)&#10;            if (prepareIntent != null) {&#10;                // Need to request VPN permission (normal app mode)&#10;                Log.d(TAG, &quot;Requesting VPN permission via dialog&quot;)&#10;                try {&#10;                    vpnPermissionLauncher.launch(prepareIntent)&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;Failed to launch VPN permission dialog&quot;, e)&#10;                    // If dialog launch fails, try to start service anyway&#10;                    // (might work if Device Owner)&#10;                    startVpnServiceInternal()&#10;                }&#10;            } else {&#10;                // Permission already granted (Device Owner or previously authorized)&#10;                Log.d(TAG, &quot;VPN permission already granted (Device Owner or previously authorized)&quot;)&#10;                startVpnServiceInternal()&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error starting VPN&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun startVpnServiceInternal() {&#10;        val intent = Intent(this, SinkholeVpnService::class.java)&#10;        try {&#10;            ContextCompat.startForegroundService(this, intent)&#10;            Log.d(TAG, &quot;Started Sinkhole VPN service&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to start Sinkhole VPN service&quot;, e)&#10;        }&#10;    }&#10;&#10;    public fun stopSinkholeVpn() {&#10;        val intent = Intent(this, SinkholeVpnService::class.java)&#10;        stopService(intent)&#10;        Log.d(TAG, &quot;Stopped Sinkhole VPN service&quot;)&#10;    }&#10;&#10;&#10;    companion object {&#10;        private const val TAG = &quot;MainActivity&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DebugUI(stateInfo: GpsTrackingService.StateInfo?, context: Context) {&#10;    val scrollState = rememberScrollState()&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;GPS Tracker Debug UI&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Current Time&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Current Time&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;                        .format(Date()),&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;&#10;        // App State&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Current State&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;&#10;                val stateColor = when (stateInfo?.state) {&#10;                    AppState.IDLE -&gt; Color.Gray&#10;                    AppState.AWAKE -&gt; Color.Green&#10;                    AppState.BATTERY_CHECK -&gt; Color.Yellow&#10;                    null -&gt; Color.Red&#10;                }&#10;&#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(top = 8.dp)&#10;                        .background(stateColor)&#10;                        .padding(8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = stateInfo?.state?.name ?: &quot;UNKNOWN&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Device Owner Status&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Device Owner Status&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = if (stateInfo?.isDeviceOwner == true) &quot;✓ Device Owner&quot; else &quot;✗ Not Device Owner&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = if (stateInfo?.isDeviceOwner == true) Color.Green else Color.Red&#10;                )&#10;&#10;                // Show hidden apps count if device owner&#10;                if (stateInfo?.isDeviceOwner == true) {&#10;                    Text(&#10;                        text = &quot;Hidden Apps: ${stateInfo.hiddenAppsCount}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;System Optimized for Battery&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = Color.Gray&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Battery Info&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Battery&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = &quot;Level: ${stateInfo?.batteryLevel ?: &quot;N/A&quot;}%&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;                Text(&#10;                    text = &quot;Charging: ${if (stateInfo?.isCharging == true) &quot;Yes&quot; else &quot;No&quot;}&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;&#10;        // HTTP Info (only show when awake)&#10;        if (stateInfo?.state == AppState.AWAKE) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;            ) {&#10;                Column(modifier = Modifier.padding(16.dp)) {&#10;                    Text(&#10;                        text = &quot;HTTP API Connection&quot;,&#10;                        style = MaterialTheme.typography.titleMedium&#10;                    )&#10;&#10;                    Row(&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(16.dp)&#10;                                .background(&#10;                                    if (stateInfo?.httpConnected == true) Color.Green else Color.Red&#10;                                )&#10;                        )&#10;                        Text(&#10;                            text = if (stateInfo?.httpConnected == true) &quot;Ready&quot; else &quot;Not Ready&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Endpoint: ${stateInfo?.apiEndpoint ?: &quot;N/A&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Device ID: ${stateInfo?.deviceId ?: &quot;N/A&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;&#10;            // GPS Tracking Info&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;            ) {&#10;                Column(modifier = Modifier.padding(16.dp)) {&#10;                    Text(&#10;                        text = &quot;GPS Tracking&quot;,&#10;                        style = MaterialTheme.typography.titleMedium&#10;                    )&#10;&#10;                    Row(&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(16.dp)&#10;                                .background(&#10;                                    if (stateInfo?.gpsTracking == true) Color.Green else Color.Red&#10;                                )&#10;                        )&#10;                        Text(&#10;                            text = if (stateInfo?.gpsTracking == true) &quot;Active&quot; else &quot;Inactive&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                    }&#10;&#10;                    Text(&#10;                        text = &quot;Update interval: ${AppConfig.GPS_UPDATE_INTERVAL_MS / 1000}s&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Awake Time Slots&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Configured Awake Time Slots&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;&#10;                AppConfig.AWAKE_TIME_SLOTS.forEach { timeSlot -&gt;&#10;                    Text(&#10;                        text = &quot;• $timeSlot&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // System Info&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;System Information&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = &quot;Battery check: Every ${AppConfig.BATTERY_CHECK_INTERVAL_MS / 60000} minutes&quot;,&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;                Text(&#10;                    text = &quot;Battery threshold: ${AppConfig.BATTERY_LOW_THRESHOLD}%&quot;,&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;            }&#10;        }&#10;&#10;        // Sinkhole VPN Control&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Internet Sinkhole (VPN)&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = &quot;Block all traffic except this app&quot;,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    modifier = Modifier.padding(top = 4.dp, bottom = 12.dp)&#10;                )&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(top = 8.dp),&#10;                    horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Button(&#10;                        onClick = {&#10;                            (context as? MainActivity)?.startSinkholeVpn()&#10;                        },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Start VPN&quot;)&#10;                    }&#10;                    Button(&#10;                        onClick = {&#10;                            (context as? MainActivity)?.stopSinkholeVpn()&#10;                        },&#10;                        modifier = Modifier.weight(1f),&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.error&#10;                        )&#10;                    ) {&#10;                        Text(&quot;Stop VPN&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>