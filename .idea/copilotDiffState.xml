<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DEVICE_OWNER_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DEVICE_OWNER_SETUP.md" />
              <option name="updatedContent" value="# GPS Tracker - Device Owner Setup Guide&#10;&#10;## Overview&#10;This guide provides step-by-step instructions to set up your Android device as a dedicated GPS tracker in kiosk mode using Device Owner privileges.&#10;&#10;## Prerequisites&#10;- Android device (minimum Android 5.1, API 22)&#10;- Computer with ADB (Android Debug Bridge) installed&#10;- USB cable&#10;- The GPS Tracker APK built and ready to install&#10;&#10;## Part 1: Initial Device Preparation&#10;&#10;### Step 1: Factory Reset the Device&#10;**IMPORTANT**: The device MUST be factory reset and have NO Google accounts added.&#10;&#10;1. Go to **Settings** &gt; **System** &gt; **Reset options** &gt; **Erase all data (factory reset)**&#10;2. Confirm and wait for the device to reset&#10;3. **DO NOT** complete the initial setup wizard yet&#10;4. **DO NOT** add any Google account&#10;&#10;### Step 2: Enable Developer Options&#10;1. Complete the basic setup wizard (skip Google account sign-in)&#10;2. Go to **Settings** &gt; **About phone**&#10;3. Tap **Build number** 7 times to enable Developer Options&#10;4. Go back to **Settings** &gt; **System** &gt; **Developer options**&#10;5. Enable **USB debugging**&#10;6. Enable **Stay awake** (optional, but recommended)&#10;&#10;### Step 3: Install ADB on Your Computer&#10;&#10;#### Windows:&#10;1. Download Android SDK Platform Tools from: https://developer.android.com/studio/releases/platform-tools&#10;2. Extract the ZIP file to a folder (e.g., `C:\platform-tools`)&#10;3. Add the folder to your PATH or navigate to it in Command Prompt&#10;&#10;#### Mac/Linux:&#10;```bash&#10;# Mac (using Homebrew)&#10;brew install android-platform-tools&#10;&#10;# Linux (Ubuntu/Debian)&#10;sudo apt-get install android-tools-adb&#10;```&#10;&#10;### Step 4: Verify ADB Connection&#10;1. Connect your Android device to the computer via USB&#10;2. On the device, allow USB debugging when prompted&#10;3. On your computer, open a terminal/command prompt and run:&#10;```bash&#10;adb devices&#10;```&#10;4. You should see your device listed. If not, check USB debugging is enabled.&#10;&#10;## Part 2: Installing the App&#10;&#10;### Step 1: Build and Install the APK&#10;```bash&#10;# Navigate to your project directory&#10;cd C:\repos\gps-tracker&#10;&#10;# Build the APK (debug version)&#10;gradlew.bat assembleDebug&#10;&#10;# Install the APK&#10;adb install app\build\outputs\apk\debug\app-debug.apk&#10;```&#10;&#10;### Step 2: Verify Installation&#10;```bash&#10;adb shell pm list packages | findstr gpstracker&#10;```&#10;You should see: `package:ovh.tenjo.gpstracker`&#10;&#10;## Part 3: Setting Device Owner&#10;&#10;### Step 1: Remove All Accounts&#10;**CRITICAL**: The device must have NO accounts (Google, Samsung, etc.)&#10;&#10;Check for accounts:&#10;```bash&#10;adb shell dumpsys account&#10;```&#10;&#10;If any accounts exist, remove them:&#10;- Go to **Settings** &gt; **Accounts** and remove all accounts&#10;&#10;### Step 2: Set as Device Owner&#10;Run this command to set the app as Device Owner:&#10;```bash&#10;adb shell dpm set-device-owner ovh.tenjo.gpstracker/.admin.DeviceAdminReceiver&#10;```&#10;&#10;**Expected output:**&#10;```&#10;Success: Device owner set to package ovh.tenjo.gpstracker&#10;Active admin set to component {ovh.tenjo.gpstracker/ovh.tenjo.gpstracker.admin.DeviceAdminReceiver}&#10;```&#10;&#10;**If you get an error:**&#10;- &quot;Not allowed to set the device owner because there are already some accounts on the device&quot;&#10;  - Remove all accounts and try again&#10;  &#10;- &quot;Trying to set the device owner, but device owner is already set&quot;&#10;  - Device owner is already configured (good!)&#10;  &#10;- &quot;Not allowed to set the device owner because there are already several users on the device&quot;&#10;  - Remove secondary users from Settings &gt; Users&#10;&#10;### Step 3: Verify Device Owner Status&#10;```bash&#10;adb shell dumpsys device_policy | findstr &quot;Device Owner&quot;&#10;```&#10;&#10;You should see your app listed as the device owner.&#10;&#10;## Part 4: Granting Additional Permissions&#10;&#10;### Grant System Permissions&#10;Run these commands to grant necessary system-level permissions:&#10;&#10;```bash&#10;# Location permissions&#10;adb shell pm grant ovh.tenjo.gpstracker android.permission.ACCESS_FINE_LOCATION&#10;adb shell pm grant ovh.tenjo.gpstracker android.permission.ACCESS_COARSE_LOCATION&#10;adb shell pm grant ovh.tenjo.gpstracker android.permission.ACCESS_BACKGROUND_LOCATION&#10;&#10;# Network permissions&#10;adb shell pm grant ovh.tenjo.gpstracker android.permission.CHANGE_NETWORK_STATE&#10;adb shell pm grant ovh.tenjo.gpstracker android.permission.CHANGE_WIFI_STATE&#10;&#10;# System write permissions (as Device Owner, these should work)&#10;adb shell pm grant ovh.tenjo.gpstracker android.permission.WRITE_SECURE_SETTINGS&#10;```&#10;&#10;### Disable Battery Optimization&#10;```bash&#10;adb shell dumpsys deviceidle whitelist +ovh.tenjo.gpstracker&#10;```&#10;&#10;## Part 5: Configure MQTT Settings&#10;&#10;Before launching the app, you need to configure your MQTT broker details.&#10;&#10;1. Edit the file: `app/src/main/java/ovh/tenjo/gpstracker/config/AppConfig.kt`&#10;2. Update these values:&#10;   ```kotlin&#10;   const val MQTT_BROKER_URL = &quot;wss://your-mqtt-broker.com:8883&quot;&#10;   const val MQTT_CLIENT_ID = &quot;gps-tracker-device-001&quot;&#10;   const val MQTT_USERNAME = &quot;your-username&quot;&#10;   const val MQTT_PASSWORD = &quot;your-password&quot;&#10;   ```&#10;3. Rebuild and reinstall the app&#10;&#10;## Part 6: Configure Tracking Schedule&#10;&#10;Edit the awake time slots in `AppConfig.kt`:&#10;&#10;```kotlin&#10;val AWAKE_TIME_SLOTS = listOf(&#10;    TimeSlot(8, 0, 9, 0),     // 08:00 -&gt; 09:00&#10;    TimeSlot(14, 0, 15, 0),   // 14:00 -&gt; 15:00&#10;    TimeSlot(18, 0, 19, 0)    // 18:00 -&gt; 19:00&#10;)&#10;```&#10;&#10;## Part 7: Launch and Test&#10;&#10;### Step 1: Launch the App&#10;```bash&#10;adb shell am start -n ovh.tenjo.gpstracker/.MainActivity&#10;```&#10;&#10;The app will automatically:&#10;- Request and receive necessary permissions&#10;- Start the foreground GPS tracking service&#10;- Enter kiosk mode (lock task)&#10;- Set itself as the home launcher&#10;&#10;### Step 2: Verify Kiosk Mode&#10;Try pressing the home button or recent apps button - they should not work. The app is now locked as the only accessible application.&#10;&#10;### Step 3: Monitor Logs&#10;```bash&#10;adb logcat -s GPSTracker:* GpsTrackingService:* MqttManager:* LocationManager:* ConnectivityManager:*&#10;```&#10;&#10;## Part 8: Network Data Restrictions&#10;&#10;As Device Owner, the app automatically restricts background data for other apps. To verify:&#10;&#10;```bash&#10;adb shell dumpsys devicepolicy&#10;```&#10;&#10;Look for application restrictions applied to other packages.&#10;&#10;## Part 9: Testing the App&#10;&#10;### Test State Transitions&#10;1. Check the debug UI - it should show:&#10;   - Current state (IDLE or AWAKE)&#10;   - Device owner status (✓ Device Owner)&#10;   - Battery level&#10;   - MQTT connection status (when AWAKE)&#10;   - GPS tracking status (when AWAKE)&#10;&#10;2. To test AWAKE state immediately, temporarily modify the time slots in `AppConfig.kt` to match the current time.&#10;&#10;### Test Battery Check&#10;The app checks battery every hour. To test immediately:&#10;- Wait for the hourly battery check&#10;- Or modify `BATTERY_CHECK_INTERVAL_MS` to a shorter interval (e.g., 300000 for 5 minutes)&#10;&#10;### Monitor MQTT Messages&#10;Use an MQTT client to subscribe to your topics:&#10;```bash&#10;# Location updates&#10;mosquitto_sub -h your-mqtt-broker.com -p 8883 -t &quot;gps/location&quot; -u your-username -P your-password --cafile ca.crt&#10;&#10;# Battery warnings&#10;mosquitto_sub -h your-mqtt-broker.com -p 8883 -t &quot;gps/battery/warning&quot; -u your-username -P your-password --cafile ca.crt&#10;```&#10;&#10;## Part 10: Exiting Kiosk Mode (For Development/Debugging)&#10;&#10;If you need to exit kiosk mode:&#10;&#10;### Method 1: Via ADB&#10;```bash&#10;adb shell am task lock stop&#10;```&#10;&#10;### Method 2: Remove Device Owner&#10;```bash&#10;adb shell dpm remove-active-admin ovh.tenjo.gpstracker/.admin.DeviceAdminReceiver&#10;```&#10;&#10;**WARNING**: This will disable all Device Owner features!&#10;&#10;## Troubleshooting&#10;&#10;### App doesn't start tracking&#10;- Check if it's within an awake time slot&#10;- Verify MQTT broker credentials are correct&#10;- Check logcat for errors&#10;&#10;### Cannot set Device Owner&#10;- Ensure device is factory reset&#10;- Remove ALL accounts (Google, Samsung, etc.)&#10;- Make sure no other profile/user exists&#10;&#10;### GPS not working&#10;- Ensure location services are enabled in Settings&#10;- Check location permissions are granted&#10;- Verify GPS hardware is working (test in Google Maps first)&#10;&#10;### MQTT connection fails&#10;- Verify broker URL, port, username, and password&#10;- Check network connectivity&#10;- Test broker connection with a different MQTT client&#10;- Check if broker requires SSL certificates&#10;&#10;### Battery drains quickly even in IDLE&#10;- Verify airplane mode is being enabled correctly&#10;- Check logcat to ensure state transitions are working&#10;- Reduce GPS update frequency in AppConfig&#10;&#10;### Other apps still using data&#10;- Verify Device Owner status is active&#10;- Check that background data restrictions were applied&#10;- Some system apps may bypass restrictions&#10;&#10;## Production Deployment Checklist&#10;&#10;- [ ] Factory reset device&#10;- [ ] Install app and set as Device Owner&#10;- [ ] Configure MQTT credentials&#10;- [ ] Set correct time slots for tracking&#10;- [ ] Test one full awake/idle cycle&#10;- [ ] Verify battery check functionality&#10;- [ ] Confirm MQTT messages are being received&#10;- [ ] Disable battery optimization&#10;- [ ] Test battery life over 24 hours&#10;- [ ] Verify kiosk mode is active&#10;- [ ] Test physical buttons (home, back, recent) are disabled&#10;- [ ] Document device ID and MQTT client ID&#10;&#10;## Advanced Configuration&#10;&#10;### Custom Time Slots&#10;Edit `AppConfig.kt` to add/modify time slots:&#10;```kotlin&#10;val AWAKE_TIME_SLOTS = listOf(&#10;    TimeSlot(6, 30, 8, 30),    // Morning&#10;    TimeSlot(12, 0, 13, 0),    // Lunch&#10;    TimeSlot(17, 0, 19, 30)    // Evening&#10;)&#10;```&#10;&#10;### Adjust GPS Update Frequency&#10;```kotlin&#10;const val GPS_UPDATE_INTERVAL_MS = 30000L    // 30 seconds (default)&#10;const val GPS_FASTEST_INTERVAL_MS = 15000L   // 15 seconds (default)&#10;```&#10;&#10;### Adjust Battery Check Frequency&#10;```kotlin&#10;const val BATTERY_CHECK_INTERVAL_MS = 3600000L  // 1 hour (default)&#10;const val BATTERY_LOW_THRESHOLD = 20             // 20% (default)&#10;```&#10;&#10;## Security Considerations&#10;&#10;1. **MQTT Credentials**: Store in a secure config file or use Android Keystore&#10;2. **Network Security**: Use WSS (WebSocket Secure) for MQTT&#10;3. **Device Physical Security**: Device owner has full control - secure the device physically&#10;4. **Remote Management**: Consider adding remote configuration/control via MQTT&#10;&#10;## Monitoring and Maintenance&#10;&#10;### Remote Monitoring&#10;Subscribe to MQTT topics to monitor:&#10;- Location updates (every 30 seconds during awake periods)&#10;- Battery warnings (when below threshold)&#10;- Device status&#10;&#10;### Log Collection&#10;```bash&#10;# Collect logs for analysis&#10;adb logcat -d &gt; gps_tracker_logs.txt&#10;```&#10;&#10;### Over-the-Air Updates&#10;To update the app remotely:&#10;1. Build new APK&#10;2. Upload to a server&#10;3. Use ADB over network or implement in-app update mechanism&#10;&#10;## Support&#10;&#10;For issues or questions:&#10;- Check logcat output for detailed error messages&#10;- Review the debug UI for current state information&#10;- Verify all prerequisites are met&#10;&#10;## Summary&#10;&#10;Your GPS tracker is now configured to:&#10;- ✅ Automatically wake up during configured time slots&#10;- ✅ Track GPS location and send to MQTT every 30 seconds&#10;- ✅ Return to idle/power-saving mode outside time slots&#10;- ✅ Check battery every hour and send warnings&#10;- ✅ Restrict network data to only this app&#10;- ✅ Run in kiosk mode as the only accessible app&#10;- ✅ Optimize battery usage during idle periods&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# GPS Tracker - Kiosk Mode Application&#10;&#10;A specialized Android GPS tracking application designed to run in kiosk mode with Device Owner privileges. The app operates on a scheduled basis, tracking GPS location during configured time slots and entering power-saving mode during idle periods.&#10;&#10;## Features&#10;&#10;- ✅ **Scheduled Tracking**: Automatically activates GPS tracking during configured time slots&#10;- ✅ **Power Optimization**: Disables GPS, mobile data, and enables airplane mode during idle periods&#10;- ✅ **MQTT Integration**: Sends location data to MQTT broker via WebSocket Secure (WSS)&#10;- ✅ **Battery Monitoring**: Hourly battery checks with low battery warnings via MQTT&#10;- ✅ **Kiosk Mode**: Runs as the only accessible app with Device Owner privileges&#10;- ✅ **Network Control**: Restricts background data for all other apps to minimize data usage&#10;- ✅ **Debug UI**: Real-time display of tracking state, MQTT connection, battery, and GPS status&#10;&#10;## How It Works&#10;&#10;### States&#10;&#10;1. **IDLE State**&#10;   - GPS disabled&#10;   - Mobile data disabled&#10;   - WiFi disabled&#10;   - Airplane mode enabled&#10;   - Maximum power savings&#10;&#10;2. **AWAKE State**&#10;   - Airplane mode disabled&#10;   - Mobile data enabled&#10;   - MQTT connected&#10;   - GPS active, sending location every 30 seconds&#10;   - Active during configured time slots&#10;&#10;3. **BATTERY_CHECK State**&#10;   - Occurs every hour&#10;   - Temporarily enables network (WiFi preferred, then mobile data)&#10;   - Checks battery level&#10;   - Sends MQTT warning if battery below threshold (20% default)&#10;   - Returns to previous state&#10;&#10;### Default Time Slots&#10;&#10;The app is configured to be AWAKE during:&#10;- 08:00 - 09:00&#10;- 14:00 - 15:00&#10;- 18:00 - 19:00&#10;&#10;Outside these times, it enters IDLE state for maximum battery savings.&#10;&#10;## Prerequisites&#10;&#10;- Android device (minimum API 22 / Android 5.1)&#10;- Device must be factory reset with no accounts&#10;- ADB (Android Debug Bridge) installed on computer&#10;- MQTT broker with WebSocket support&#10;&#10;## Quick Start&#10;&#10;1. **Configure MQTT Settings**&#10;   - Edit `app/src/main/java/ovh/tenjo/gpstracker/config/AppConfig.kt`&#10;   - Update broker URL, credentials, and topics&#10;&#10;2. **Build the App**&#10;   ```bash&#10;   gradlew.bat assembleDebug&#10;   ```&#10;&#10;3. **Follow Device Owner Setup**&#10;   - See [DEVICE_OWNER_SETUP.md](DEVICE_OWNER_SETUP.md) for detailed instructions&#10;   - Factory reset device&#10;   - Install app&#10;   - Set as Device Owner via ADB&#10;&#10;## Configuration&#10;&#10;### Time Slots&#10;Edit `AppConfig.kt` to configure when the device should be awake:&#10;&#10;```kotlin&#10;val AWAKE_TIME_SLOTS = listOf(&#10;    TimeSlot(8, 0, 9, 0),     // 08:00 -&gt; 09:00&#10;    TimeSlot(14, 0, 15, 0),   // 14:00 -&gt; 15:00&#10;    TimeSlot(18, 0, 19, 0)    // 18:00 -&gt; 19:00&#10;)&#10;```&#10;&#10;### MQTT Broker&#10;```kotlin&#10;const val MQTT_BROKER_URL = &quot;wss://your-mqtt-broker.com:8883&quot;&#10;const val MQTT_CLIENT_ID = &quot;gps-tracker-device&quot;&#10;const val MQTT_USERNAME = &quot;your-username&quot;&#10;const val MQTT_PASSWORD = &quot;your-password&quot;&#10;const val MQTT_TOPIC_LOCATION = &quot;gps/location&quot;&#10;const val MQTT_TOPIC_BATTERY = &quot;gps/battery/warning&quot;&#10;```&#10;&#10;### GPS Settings&#10;```kotlin&#10;const val GPS_UPDATE_INTERVAL_MS = 30000L    // 30 seconds&#10;const val GPS_FASTEST_INTERVAL_MS = 15000L   // 15 seconds&#10;```&#10;&#10;### Battery Settings&#10;```kotlin&#10;const val BATTERY_CHECK_INTERVAL_MS = 3600000L  // 1 hour&#10;const val BATTERY_LOW_THRESHOLD = 20             // 20%&#10;```&#10;&#10;## MQTT Message Format&#10;&#10;### Location Message (gps/location)&#10;```json&#10;{&#10;  &quot;latitude&quot;: 40.7128,&#10;  &quot;longitude&quot;: -74.0060,&#10;  &quot;accuracy&quot;: 15.5,&#10;  &quot;timestamp&quot;: 1700000000000,&#10;  &quot;device_id&quot;: &quot;gps-tracker-device&quot;&#10;}&#10;```&#10;&#10;### Battery Warning Message (gps/battery/warning)&#10;```json&#10;{&#10;  &quot;battery_level&quot;: 18,&#10;  &quot;is_charging&quot;: false,&#10;  &quot;timestamp&quot;: 1700000000000,&#10;  &quot;device_id&quot;: &quot;gps-tracker-device&quot;&#10;}&#10;```&#10;&#10;## Project Structure&#10;&#10;```&#10;app/src/main/java/ovh/tenjo/gpstracker/&#10;├── MainActivity.kt                    # Main UI with debug display&#10;├── admin/&#10;│   └── DeviceAdminReceiver.kt        # Device owner receiver&#10;├── config/&#10;│   └── AppConfig.kt                  # All configuration settings&#10;├── location/&#10;│   └── LocationManager.kt            # GPS location handling&#10;├── model/&#10;│   ├── AppState.kt                   # App state enum&#10;│   └── TimeSlot.kt                   # Time slot data class&#10;├── mqtt/&#10;│   └── MqttManager.kt                # MQTT client management&#10;├── service/&#10;│   └── GpsTrackingService.kt         # Foreground tracking service&#10;└── utils/&#10;    ├── BatteryMonitor.kt             # Battery status monitoring&#10;    └── ConnectivityManager.kt        # Network control (Device Owner)&#10;```&#10;&#10;## Debug UI&#10;&#10;The app displays a comprehensive debug interface showing:&#10;- Current date/time&#10;- Current state (IDLE/AWAKE/BATTERY_CHECK)&#10;- Device Owner status&#10;- Battery level and charging status&#10;- MQTT connection details (when AWAKE)&#10;- GPS tracking status (when AWAKE)&#10;- Configured time slots&#10;- System information&#10;&#10;## Device Owner Privileges&#10;&#10;The app uses Device Owner mode to:&#10;- Enable/disable mobile data programmatically&#10;- Enable/disable airplane mode&#10;- Restrict background data for other apps&#10;- Lock the device in kiosk mode (lock task)&#10;- Disable status bar and keyguard&#10;&#10;## Data Usage Optimization&#10;&#10;To minimize data charges:&#10;1. Only this app can access network during AWAKE state&#10;2. Background data restricted for all other apps&#10;3. Compact JSON messages via MQTT&#10;4. Configurable update intervals&#10;5. Network disabled during IDLE state&#10;6. WiFi preferred over mobile data for battery checks&#10;&#10;## Battery Optimization&#10;&#10;The app maximizes battery life by:&#10;1. Enabling airplane mode during IDLE (disables all radios)&#10;2. Stopping GPS when not in AWAKE state&#10;3. Using partial wake lock (CPU only)&#10;4. Efficient MQTT connection management&#10;5. Minimal UI updates&#10;6. Scheduled operation only during required times&#10;&#10;## Monitoring&#10;&#10;Subscribe to MQTT topics to monitor devices:&#10;&#10;```bash&#10;# Monitor location updates&#10;mosquitto_sub -h broker.com -p 8883 -t &quot;gps/location&quot; -u user -P pass&#10;&#10;# Monitor battery warnings&#10;mosquitto_sub -h broker.com -p 8883 -t &quot;gps/battery/warning&quot; -u user -P pass&#10;```&#10;&#10;## Troubleshooting&#10;&#10;See [DEVICE_OWNER_SETUP.md](DEVICE_OWNER_SETUP.md) for detailed troubleshooting steps.&#10;&#10;Common issues:&#10;- **Cannot set Device Owner**: Device must be factory reset with no accounts&#10;- **GPS not working**: Check location permissions and services&#10;- **MQTT fails**: Verify broker credentials and WSS support&#10;- **High battery drain**: Check state transitions in logs&#10;&#10;## Security Notes&#10;&#10;- Store MQTT credentials securely (consider Android Keystore)&#10;- Use WSS (WebSocket Secure) for encrypted MQTT&#10;- Physical device security is critical with Device Owner privileges&#10;- Disable ADB in production if not needed for remote management&#10;&#10;## Development&#10;&#10;```bash&#10;# Build debug APK&#10;gradlew.bat assembleDebug&#10;&#10;# Install via ADB&#10;adb install app\build\outputs\apk\debug\app-debug.apk&#10;&#10;# View logs&#10;adb logcat -s GpsTrackingService:*&#10;```&#10;&#10;## License&#10;&#10;This project is provided as-is for dedicated GPS tracking use cases.&#10;&#10;## Requirements Summary&#10;&#10;- **Minimum SDK**: 22 (Android 5.1)&#10;- **Target SDK**: 36 (Android 14)&#10;- **Permissions**: Location, Network, Device Admin&#10;- **Special Requirements**: Device Owner mode&#10;&#10;## Support&#10;&#10;For detailed setup instructions, see [DEVICE_OWNER_SETUP.md](DEVICE_OWNER_SETUP.md)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;ovh.tenjo.gpstracker&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;ovh.tenjo.gpstracker&quot;&#10;        minSdk = 22&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;ovh.tenjo.gpstracker&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;ovh.tenjo.gpstracker&quot;&#10;        minSdk = 22&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;    implementation(libs.play.services.location)&#10;    implementation(libs.mqtt.client)&#10;    implementation(libs.androidx.work.runtime.ktx)&#10;    implementation(&quot;androidx.localbroadcastmanager:localbroadcastmanager:1.1.0&quot;)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.GPSTracker&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.GPSTracker&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Hardware features --&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.location.gps&quot; android:required=&quot;true&quot; /&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.telephony&quot; android:required=&quot;false&quot; /&gt;&#10;&#10;    &lt;!-- Permissions for GPS tracking --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;&#10;&#10;    &lt;!-- Permissions for network and connectivity --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&#10;&#10;    &lt;!-- Permissions for device admin and kiosk mode --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot;&#10;        tools:ignore=&quot;ProtectedPermissions&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_SECURE_SETTINGS&quot;&#10;        tools:ignore=&quot;ProtectedPermissions&quot; /&gt;&#10;&#10;    &lt;!-- Permissions for wakelock and foreground service --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_LOCATION&quot; /&gt;&#10;&#10;    &lt;!-- Permission for battery stats --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.BATTERY_STATS&quot;&#10;        tools:ignore=&quot;ProtectedPermissions&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot; /&gt;&#10;&#10;    &lt;!-- Permission for scheduling exact alarms --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.SCHEDULE_EXACT_ALARM&quot; /&gt;&#10;&#10;    &lt;!-- Permission for airplane mode --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_APN_SETTINGS&quot;&#10;        tools:ignore=&quot;ProtectedPermissions&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.GPSTracker&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:launchMode=&quot;singleTask&quot;&#10;            android:theme=&quot;@style/Theme.GPSTracker&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.HOME&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- Device Admin Receiver for kiosk mode --&gt;&#10;        &lt;receiver&#10;            android:name=&quot;.admin.DeviceAdminReceiver&quot;&#10;            android:permission=&quot;android.permission.BIND_DEVICE_ADMIN&quot;&#10;            android:exported=&quot;true&quot;&gt;&#10;            &lt;meta-data&#10;                android:name=&quot;android.app.device_admin&quot;&#10;                android:resource=&quot;@xml/device_admin&quot; /&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.app.action.DEVICE_ADMIN_ENABLED&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/receiver&gt;&#10;&#10;        &lt;!-- Foreground Service for GPS tracking --&gt;&#10;        &lt;service&#10;            android:name=&quot;.service.GpsTrackingService&quot;&#10;            android:enabled=&quot;true&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:foregroundServiceType=&quot;location&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/MainActivity.kt" />
              <option name="originalContent" value="package ovh.tenjo.gpstracker&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import ovh.tenjo.gpstracker.ui.theme.GPSTrackerTheme&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            GPSTrackerTheme {&#10;                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding -&gt;&#10;                    Greeting(&#10;                        name = &quot;Android&quot;,&#10;                        modifier = Modifier.padding(innerPadding)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun Greeting(name: String, modifier: Modifier = Modifier) {&#10;    Text(&#10;        text = &quot;Hello $name!&quot;,&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun GreetingPreview() {&#10;    GPSTrackerTheme {&#10;        Greeting(&quot;Android&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker&#10;&#10;import android.Manifest&#10;import android.app.ActivityManager&#10;import android.content.*&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.util.Log&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.content.ContextCompat&#10;import ovh.tenjo.gpstracker.config.AppConfig&#10;import ovh.tenjo.gpstracker.model.AppState&#10;import ovh.tenjo.gpstracker.service.GpsTrackingService&#10;import ovh.tenjo.gpstracker.ui.theme.GPSTrackerTheme&#10;import java.text.SimpleDateFormat&#10;import java.util.*&#10;&#10;class MainActivity : ComponentActivity() {&#10;    &#10;    private var trackingService: GpsTrackingService? = null&#10;    private var serviceBound = false&#10;    &#10;    private var stateInfo by mutableStateOf&lt;GpsTrackingService.StateInfo?&gt;(null)&#10;    &#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            val binder = service as GpsTrackingService.LocalBinder&#10;            trackingService = binder.getService()&#10;            serviceBound = true&#10;            updateStateInfo()&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            trackingService = null&#10;            serviceBound = false&#10;        }&#10;    }&#10;    &#10;    private val stateUpdateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            updateStateInfo()&#10;        }&#10;    }&#10;    &#10;    private val permissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        val allGranted = permissions.values.all { it }&#10;        if (allGranted) {&#10;            startTrackingService()&#10;        } else {&#10;            Log.e(TAG, &quot;Some permissions not granted&quot;)&#10;        }&#10;    }&#10;    &#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        &#10;        // Request permissions&#10;        checkAndRequestPermissions()&#10;        &#10;        // Register broadcast receiver&#10;        val filter = IntentFilter(GpsTrackingService.ACTION_STATE_UPDATE)&#10;        registerReceiver(stateUpdateReceiver, filter)&#10;        &#10;        setContent {&#10;            GPSTrackerTheme {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    DebugUI(stateInfo)&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Start lock task mode if device owner&#10;        try {&#10;            startLockTask()&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;Could not start lock task mode&quot;, e)&#10;        }&#10;    }&#10;    &#10;    override fun onStart() {&#10;        super.onStart()&#10;        // Bind to service&#10;        val intent = Intent(this, GpsTrackingService::class.java)&#10;        bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    override fun onStop() {&#10;        super.onStop()&#10;        if (serviceBound) {&#10;            unbindService(serviceConnection)&#10;            serviceBound = false&#10;        }&#10;    }&#10;    &#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        try {&#10;            unregisterReceiver(stateUpdateReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error unregistering receiver&quot;, e)&#10;        }&#10;    }&#10;    &#10;    private fun checkAndRequestPermissions() {&#10;        val permissions = mutableListOf(&#10;            Manifest.permission.ACCESS_FINE_LOCATION,&#10;            Manifest.permission.ACCESS_COARSE_LOCATION,&#10;            Manifest.permission.INTERNET,&#10;            Manifest.permission.ACCESS_NETWORK_STATE,&#10;            Manifest.permission.CHANGE_NETWORK_STATE,&#10;            Manifest.permission.ACCESS_WIFI_STATE,&#10;            Manifest.permission.CHANGE_WIFI_STATE&#10;        )&#10;        &#10;        // Add background location for Android 10+&#10;        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.Q) {&#10;            permissions.add(Manifest.permission.ACCESS_BACKGROUND_LOCATION)&#10;        }&#10;        &#10;        val permissionsToRequest = permissions.filter {&#10;            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED&#10;        }&#10;        &#10;        if (permissionsToRequest.isNotEmpty()) {&#10;            permissionLauncher.launch(permissionsToRequest.toTypedArray())&#10;        } else {&#10;            startTrackingService()&#10;        }&#10;    }&#10;    &#10;    private fun startTrackingService() {&#10;        if (!isServiceRunning(GpsTrackingService::class.java)) {&#10;            val intent = Intent(this, GpsTrackingService::class.java)&#10;            ContextCompat.startForegroundService(this, intent)&#10;            Log.d(TAG, &quot;Started tracking service&quot;)&#10;        }&#10;    }&#10;    &#10;    private fun isServiceRunning(serviceClass: Class&lt;*&gt;): Boolean {&#10;        val manager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        return manager.getRunningServices(Integer.MAX_VALUE)&#10;            .any { it.service.className == serviceClass.name }&#10;    }&#10;    &#10;    private fun updateStateInfo() {&#10;        stateInfo = trackingService?.getStateInfo()&#10;    }&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MainActivity&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun DebugUI(stateInfo: GpsTrackingService.StateInfo?) {&#10;    val scrollState = rememberScrollState()&#10;    &#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(scrollState)&#10;            .padding(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;GPS Tracker Debug UI&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Current Time&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Current Time&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.getDefault())&#10;                        .format(Date()),&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;        &#10;        // App State&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Current State&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                &#10;                val stateColor = when (stateInfo?.state) {&#10;                    AppState.IDLE -&gt; Color.Gray&#10;                    AppState.AWAKE -&gt; Color.Green&#10;                    AppState.BATTERY_CHECK -&gt; Color.Yellow&#10;                    null -&gt; Color.Red&#10;                }&#10;                &#10;                Box(&#10;                    modifier = Modifier&#10;                        .padding(top = 8.dp)&#10;                        .background(stateColor)&#10;                        .padding(8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = stateInfo?.state?.name ?: &quot;UNKNOWN&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Device Owner Status&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Device Owner Status&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = if (stateInfo?.isDeviceOwner == true) &quot;✓ Device Owner&quot; else &quot;✗ Not Device Owner&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    color = if (stateInfo?.isDeviceOwner == true) Color.Green else Color.Red&#10;                )&#10;            }&#10;        }&#10;        &#10;        // Battery Info&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Battery&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = &quot;Level: ${stateInfo?.batteryLevel ?: &quot;N/A&quot;}%&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;                Text(&#10;                    text = &quot;Charging: ${if (stateInfo?.isCharging == true) &quot;Yes&quot; else &quot;No&quot;}&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;        &#10;        // MQTT Info (only show when awake)&#10;        if (stateInfo?.state == AppState.AWAKE) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;            ) {&#10;                Column(modifier = Modifier.padding(16.dp)) {&#10;                    Text(&#10;                        text = &quot;MQTT Connection&quot;,&#10;                        style = MaterialTheme.typography.titleMedium&#10;                    )&#10;                    &#10;                    Row(&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(16.dp)&#10;                                .background(&#10;                                    if (stateInfo?.mqttConnected == true) Color.Green else Color.Red&#10;                                )&#10;                        )&#10;                        Text(&#10;                            text = if (stateInfo?.mqttConnected == true) &quot;Connected&quot; else &quot;Disconnected&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                    }&#10;                    &#10;                    Text(&#10;                        text = &quot;Broker: ${stateInfo?.mqttBroker ?: &quot;N/A&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                    Text(&#10;                        text = &quot;Client ID: ${stateInfo?.mqttClientId ?: &quot;N/A&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall&#10;                    )&#10;                }&#10;            }&#10;            &#10;            // GPS Tracking Info&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;            ) {&#10;                Column(modifier = Modifier.padding(16.dp)) {&#10;                    Text(&#10;                        text = &quot;GPS Tracking&quot;,&#10;                        style = MaterialTheme.typography.titleMedium&#10;                    )&#10;                    &#10;                    Row(&#10;                        modifier = Modifier.padding(top = 8.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(16.dp)&#10;                                .background(&#10;                                    if (stateInfo?.gpsTracking == true) Color.Green else Color.Red&#10;                                )&#10;                        )&#10;                        Text(&#10;                            text = if (stateInfo?.gpsTracking == true) &quot;Active&quot; else &quot;Inactive&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                    }&#10;                    &#10;                    Text(&#10;                        text = &quot;Update interval: ${AppConfig.GPS_UPDATE_INTERVAL_MS / 1000}s&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Awake Time Slots&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;Configured Awake Time Slots&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                &#10;                AppConfig.AWAKE_TIME_SLOTS.forEach { timeSlot -&gt;&#10;                    Text(&#10;                        text = &quot;• $timeSlot&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        &#10;        // System Info&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp)&#10;        ) {&#10;            Column(modifier = Modifier.padding(16.dp)) {&#10;                Text(&#10;                    text = &quot;System Information&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;                Text(&#10;                    text = &quot;Battery check: Every ${AppConfig.BATTERY_CHECK_INTERVAL_MS / 60000} minutes&quot;,&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;                Text(&#10;                    text = &quot;Battery threshold: ${AppConfig.BATTERY_LOW_THRESHOLD}%&quot;,&#10;                    style = MaterialTheme.typography.bodySmall&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/admin/DeviceAdminReceiver.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/admin/DeviceAdminReceiver.kt" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.admin&#10;&#10;import android.app.admin.DeviceAdminReceiver&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.util.Log&#10;&#10;class DeviceAdminReceiver : DeviceAdminReceiver() {&#10;    &#10;    override fun onEnabled(context: Context, intent: Intent) {&#10;        super.onEnabled(context, intent)&#10;        Log.d(TAG, &quot;Device Admin Enabled&quot;)&#10;    }&#10;&#10;    override fun onDisabled(context: Context, intent: Intent) {&#10;        super.onDisabled(context, intent)&#10;        Log.d(TAG, &quot;Device Admin Disabled&quot;)&#10;    }&#10;&#10;    companion object {&#10;        private const val TAG = &quot;DeviceAdminReceiver&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/config/AppConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/config/AppConfig.kt" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.config&#10;&#10;import ovh.tenjo.gpstracker.model.TimeSlot&#10;&#10;object AppConfig {&#10;    // MQTT Configuration&#10;    const val MQTT_BROKER_URL = &quot;wss://your-mqtt-broker.com:8883&quot;&#10;    const val MQTT_CLIENT_ID = &quot;gps-tracker-device&quot;&#10;    const val MQTT_USERNAME = &quot;your-username&quot;&#10;    const val MQTT_PASSWORD = &quot;your-password&quot;&#10;    const val MQTT_TOPIC_LOCATION = &quot;gps/location&quot;&#10;    const val MQTT_TOPIC_BATTERY = &quot;gps/battery/warning&quot;&#10;    &#10;    // GPS Configuration&#10;    const val GPS_UPDATE_INTERVAL_MS = 30000L // 30 seconds&#10;    const val GPS_FASTEST_INTERVAL_MS = 15000L // 15 seconds&#10;    &#10;    // Battery Configuration&#10;    const val BATTERY_CHECK_INTERVAL_MS = 3600000L // 1 hour&#10;    const val BATTERY_LOW_THRESHOLD = 20 // 20% battery level&#10;    &#10;    // Awake Time Slots (hardcoded schedule)&#10;    val AWAKE_TIME_SLOTS = listOf(&#10;        TimeSlot(8, 0, 9, 0),     // 08:00 -&gt; 09:00&#10;        TimeSlot(14, 0, 15, 0),   // 14:00 -&gt; 15:00&#10;        TimeSlot(18, 0, 19, 0)    // 18:00 -&gt; 19:00&#10;    )&#10;    &#10;    // Check if current time is within any awake time slot&#10;    fun isAwakeTime(hour: Int, minute: Int): Boolean {&#10;        return AWAKE_TIME_SLOTS.any { it.isInTimeSlot(hour, minute) }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/location/LocationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/location/LocationManager.kt" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.location&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.location.Location&#10;import android.os.Looper&#10;import android.util.Log&#10;import androidx.core.app.ActivityCompat&#10;import com.google.android.gms.location.*&#10;import ovh.tenjo.gpstracker.config.AppConfig&#10;&#10;class LocationManager(private val context: Context) {&#10;    &#10;    private val fusedLocationClient: FusedLocationProviderClient by lazy {&#10;        LocationServices.getFusedLocationProviderClient(context)&#10;    }&#10;    &#10;    private var locationCallback: LocationCallback? = null&#10;    private var isTracking = false&#10;    &#10;    interface LocationUpdateListener {&#10;        fun onLocationUpdate(location: Location)&#10;        fun onLocationError(error: String)&#10;    }&#10;    &#10;    private var listener: LocationUpdateListener? = null&#10;    &#10;    fun setLocationUpdateListener(listener: LocationUpdateListener) {&#10;        this.listener = listener&#10;    }&#10;    &#10;    fun startLocationUpdates() {&#10;        if (!hasLocationPermission()) {&#10;            Log.e(TAG, &quot;Location permission not granted&quot;)&#10;            listener?.onLocationError(&quot;Location permission not granted&quot;)&#10;            return&#10;        }&#10;        &#10;        if (isTracking) {&#10;            Log.d(TAG, &quot;Already tracking location&quot;)&#10;            return&#10;        }&#10;        &#10;        val locationRequest = LocationRequest.create().apply {&#10;            interval = AppConfig.GPS_UPDATE_INTERVAL_MS&#10;            fastestInterval = AppConfig.GPS_FASTEST_INTERVAL_MS&#10;            priority = LocationRequest.PRIORITY_HIGH_ACCURACY&#10;        }&#10;        &#10;        locationCallback = object : LocationCallback() {&#10;            override fun onLocationResult(locationResult: LocationResult) {&#10;                locationResult.lastLocation?.let { location -&gt;&#10;                    Log.d(TAG, &quot;Location update: ${location.latitude}, ${location.longitude}&quot;)&#10;                    listener?.onLocationUpdate(location)&#10;                }&#10;            }&#10;            &#10;            override fun onLocationAvailability(availability: LocationAvailability) {&#10;                if (!availability.isLocationAvailable) {&#10;                    Log.w(TAG, &quot;Location not available&quot;)&#10;                    listener?.onLocationError(&quot;Location not available&quot;)&#10;                }&#10;            }&#10;        }&#10;        &#10;        try {&#10;            fusedLocationClient.requestLocationUpdates(&#10;                locationRequest,&#10;                locationCallback!!,&#10;                Looper.getMainLooper()&#10;            )&#10;            isTracking = true&#10;            Log.d(TAG, &quot;Started location updates&quot;)&#10;        } catch (e: SecurityException) {&#10;            Log.e(TAG, &quot;Security exception starting location updates&quot;, e)&#10;            listener?.onLocationError(&quot;Security exception: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    fun stopLocationUpdates() {&#10;        if (!isTracking) {&#10;            Log.d(TAG, &quot;Not tracking location&quot;)&#10;            return&#10;        }&#10;        &#10;        locationCallback?.let {&#10;            fusedLocationClient.removeLocationUpdates(it)&#10;            isTracking = false&#10;            Log.d(TAG, &quot;Stopped location updates&quot;)&#10;        }&#10;    }&#10;    &#10;    fun isTracking(): Boolean = isTracking&#10;    &#10;    private fun hasLocationPermission(): Boolean {&#10;        return ActivityCompat.checkSelfPermission(&#10;            context,&#10;            Manifest.permission.ACCESS_FINE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;LocationManager&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/model/AppState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/model/AppState.kt" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.model&#10;&#10;enum class AppState {&#10;    IDLE,           // Device in sleep mode, all disabled&#10;    AWAKE,          // Active tracking mode&#10;    BATTERY_CHECK   // Hourly battery check mode&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/model/TimeSlot.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/model/TimeSlot.kt" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.model&#10;&#10;data class TimeSlot(&#10;    val startHour: Int,&#10;    val startMinute: Int,&#10;    val endHour: Int,&#10;    val endMinute: Int&#10;) {&#10;    fun isInTimeSlot(hour: Int, minute: Int): Boolean {&#10;        val currentMinutes = hour * 60 + minute&#10;        val startMinutes = startHour * 60 + startMinute&#10;        val endMinutes = endHour * 60 + endMinute&#10;        &#10;        return currentMinutes in startMinutes until endMinutes&#10;    }&#10;    &#10;    override fun toString(): String {&#10;        return String.format(&quot;%02d:%02d -&gt; %02d:%02d&quot;, startHour, startMinute, endHour, endMinute)&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/mqtt/MqttManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/mqtt/MqttManager.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.mqtt&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import org.eclipse.paho.client.mqttv3.*&#10;import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence&#10;import org.json.JSONObject&#10;import ovh.tenjo.gpstracker.config.AppConfig&#10;import java.util.concurrent.Executors&#10;&#10;class MqttManager(private val context: Context) {&#10;    &#10;    private var mqttClient: MqttClient? = null&#10;    private var isConnected = false&#10;    private val executor = Executors.newSingleThreadExecutor()&#10;    &#10;    interface ConnectionCallback {&#10;        fun onConnected()&#10;        fun onDisconnected()&#10;        fun onError(error: String)&#10;    }&#10;    &#10;    private var connectionCallback: ConnectionCallback? = null&#10;    &#10;    fun setConnectionCallback(callback: ConnectionCallback) {&#10;        this.connectionCallback = callback&#10;    }&#10;    &#10;    fun connect() {&#10;        executor.execute {&#10;            try {&#10;                val persistence = MemoryPersistence()&#10;                mqttClient = MqttClient(&#10;                    AppConfig.MQTT_BROKER_URL,&#10;                    AppConfig.MQTT_CLIENT_ID,&#10;                    persistence&#10;                )&#10;                &#10;                val options = MqttConnectOptions().apply {&#10;                    userName = AppConfig.MQTT_USERNAME&#10;                    password = AppConfig.MQTT_PASSWORD.toCharArray()&#10;                    isCleanSession = true&#10;                    connectionTimeout = 30&#10;                    keepAliveInterval = 60&#10;                    isAutomaticReconnect = true&#10;                }&#10;                &#10;                mqttClient?.setCallback(object : MqttCallback {&#10;                    override fun connectionLost(cause: Throwable?) {&#10;                        Log.w(TAG, &quot;Connection lost&quot;, cause)&#10;                        isConnected = false&#10;                        connectionCallback?.onDisconnected()&#10;                    }&#10;                    &#10;                    override fun messageArrived(topic: String?, message: MqttMessage?) {&#10;                        // Not expecting incoming messages&#10;                    }&#10;                    &#10;                    override fun deliveryComplete(token: IMqttDeliveryToken?) {&#10;                        Log.d(TAG, &quot;Message delivered&quot;)&#10;                    }&#10;                })&#10;                &#10;                mqttClient?.connect(options)&#10;                isConnected = true&#10;                Log.d(TAG, &quot;Connected to MQTT broker&quot;)&#10;                connectionCallback?.onConnected()&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error connecting to MQTT&quot;, e)&#10;                isConnected = false&#10;                connectionCallback?.onError(e.message ?: &quot;Unknown error&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun disconnect() {&#10;        executor.execute {&#10;            try {&#10;                mqttClient?.disconnect()&#10;                mqttClient?.close()&#10;                isConnected = false&#10;                Log.d(TAG, &quot;Disconnected from MQTT broker&quot;)&#10;                connectionCallback?.onDisconnected()&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error disconnecting from MQTT&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun publishLocation(latitude: Double, longitude: Double, accuracy: Float, timestamp: Long) {&#10;        if (!isConnected) {&#10;            Log.w(TAG, &quot;Cannot publish - not connected&quot;)&#10;            return&#10;        }&#10;        &#10;        executor.execute {&#10;            try {&#10;                val payload = JSONObject().apply {&#10;                    put(&quot;latitude&quot;, latitude)&#10;                    put(&quot;longitude&quot;, longitude)&#10;                    put(&quot;accuracy&quot;, accuracy)&#10;                    put(&quot;timestamp&quot;, timestamp)&#10;                    put(&quot;device_id&quot;, AppConfig.MQTT_CLIENT_ID)&#10;                }&#10;                &#10;                val message = MqttMessage(payload.toString().toByteArray()).apply {&#10;                    qos = 1&#10;                    isRetained = false&#10;                }&#10;                &#10;                mqttClient?.publish(AppConfig.MQTT_TOPIC_LOCATION, message)&#10;                Log.d(TAG, &quot;Published location: $latitude, $longitude&quot;)&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error publishing location&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun publishBatteryWarning(batteryLevel: Int, isCharging: Boolean) {&#10;        if (!isConnected) {&#10;            Log.w(TAG, &quot;Cannot publish battery warning - not connected&quot;)&#10;            return&#10;        }&#10;        &#10;        executor.execute {&#10;            try {&#10;                val payload = JSONObject().apply {&#10;                    put(&quot;battery_level&quot;, batteryLevel)&#10;                    put(&quot;is_charging&quot;, isCharging)&#10;                    put(&quot;timestamp&quot;, System.currentTimeMillis())&#10;                    put(&quot;device_id&quot;, AppConfig.MQTT_CLIENT_ID)&#10;                }&#10;                &#10;                val message = MqttMessage(payload.toString().toByteArray()).apply {&#10;                    qos = 1&#10;                    isRetained = false&#10;                }&#10;                &#10;                mqttClient?.publish(AppConfig.MQTT_TOPIC_BATTERY, message)&#10;                Log.d(TAG, &quot;Published battery warning: $batteryLevel%&quot;)&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error publishing battery warning&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    fun isConnected(): Boolean = isConnected&#10;    &#10;    fun getBrokerUrl(): String = AppConfig.MQTT_BROKER_URL&#10;    &#10;    fun getClientId(): String = AppConfig.MQTT_CLIENT_ID&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MqttManager&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/service/GpsTrackingService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/service/GpsTrackingService.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.service&#10;&#10;import android.app.*&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.location.Location&#10;import android.os.*&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import ovh.tenjo.gpstracker.MainActivity&#10;import ovh.tenjo.gpstracker.R&#10;import ovh.tenjo.gpstracker.config.AppConfig&#10;import ovh.tenjo.gpstracker.location.LocationManager&#10;import ovh.tenjo.gpstracker.model.AppState&#10;import ovh.tenjo.gpstracker.mqtt.MqttManager&#10;import ovh.tenjo.gpstracker.utils.BatteryMonitor&#10;import ovh.tenjo.gpstracker.utils.ConnectivityManager&#10;import java.util.*&#10;&#10;class GpsTrackingService : Service() {&#10;    &#10;    private lateinit var locationManager: LocationManager&#10;    private lateinit var mqttManager: MqttManager&#10;    private lateinit var batteryMonitor: BatteryMonitor&#10;    private lateinit var connectivityManager: ConnectivityManager&#10;    &#10;    private var currentState: AppState = AppState.IDLE&#10;    private var wakeLock: PowerManager.WakeLock? = null&#10;    &#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private val stateCheckRunnable = object : Runnable {&#10;        override fun run() {&#10;            checkAndUpdateState()&#10;            handler.postDelayed(this, 60000) // Check every minute&#10;        }&#10;    }&#10;    &#10;    private val batteryCheckRunnable = object : Runnable {&#10;        override fun run() {&#10;            performBatteryCheck()&#10;            handler.postDelayed(this, AppConfig.BATTERY_CHECK_INTERVAL_MS)&#10;        }&#10;    }&#10;    &#10;    private val binder = LocalBinder()&#10;    &#10;    inner class LocalBinder : Binder() {&#10;        fun getService(): GpsTrackingService = this@GpsTrackingService&#10;    }&#10;    &#10;    override fun onBind(intent: Intent): IBinder = binder&#10;    &#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        Log.d(TAG, &quot;Service created&quot;)&#10;        &#10;        locationManager = LocationManager(this)&#10;        mqttManager = MqttManager(this)&#10;        batteryMonitor = BatteryMonitor(this)&#10;        connectivityManager = ConnectivityManager(this)&#10;        &#10;        setupLocationListener()&#10;        setupMqttCallback()&#10;        &#10;        createNotificationChannel()&#10;        startForeground(NOTIFICATION_ID, createNotification(&quot;Initializing...&quot;))&#10;        &#10;        acquireWakeLock()&#10;        &#10;        // Setup kiosk mode if device owner&#10;        if (connectivityManager.isDeviceOwner()) {&#10;            connectivityManager.enableKioskMode()&#10;            connectivityManager.restrictBackgroundData()&#10;        }&#10;        &#10;        // Start state checking&#10;        handler.post(stateCheckRunnable)&#10;        &#10;        // Start battery checking (every hour)&#10;        handler.post(batteryCheckRunnable)&#10;    }&#10;    &#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        Log.d(TAG, &quot;Service destroyed&quot;)&#10;        &#10;        handler.removeCallbacks(stateCheckRunnable)&#10;        handler.removeCallbacks(batteryCheckRunnable)&#10;        &#10;        locationManager.stopLocationUpdates()&#10;        mqttManager.disconnect()&#10;        &#10;        releaseWakeLock()&#10;    }&#10;    &#10;    private fun setupLocationListener() {&#10;        locationManager.setLocationUpdateListener(object : LocationManager.LocationUpdateListener {&#10;            override fun onLocationUpdate(location: Location) {&#10;                if (currentState == AppState.AWAKE) {&#10;                    mqttManager.publishLocation(&#10;                        location.latitude,&#10;                        location.longitude,&#10;                        location.accuracy,&#10;                        location.time&#10;                    )&#10;                    updateNotification(&quot;Location sent: ${location.latitude}, ${location.longitude}&quot;)&#10;                    broadcastStateUpdate()&#10;                }&#10;            }&#10;            &#10;            override fun onLocationError(error: String) {&#10;                Log.e(TAG, &quot;Location error: $error&quot;)&#10;                updateNotification(&quot;Location error: $error&quot;)&#10;            }&#10;        })&#10;    }&#10;    &#10;    private fun setupMqttCallback() {&#10;        mqttManager.setConnectionCallback(object : MqttManager.ConnectionCallback {&#10;            override fun onConnected() {&#10;                Log.d(TAG, &quot;MQTT connected&quot;)&#10;                updateNotification(&quot;MQTT Connected&quot;)&#10;                broadcastStateUpdate()&#10;            }&#10;            &#10;            override fun onDisconnected() {&#10;                Log.d(TAG, &quot;MQTT disconnected&quot;)&#10;                updateNotification(&quot;MQTT Disconnected&quot;)&#10;                broadcastStateUpdate()&#10;            }&#10;            &#10;            override fun onError(error: String) {&#10;                Log.e(TAG, &quot;MQTT error: $error&quot;)&#10;                updateNotification(&quot;MQTT Error: $error&quot;)&#10;            }&#10;        })&#10;    }&#10;    &#10;    private fun checkAndUpdateState() {&#10;        val calendar = Calendar.getInstance()&#10;        val hour = calendar.get(Calendar.HOUR_OF_DAY)&#10;        val minute = calendar.get(Calendar.MINUTE)&#10;        &#10;        val shouldBeAwake = AppConfig.isAwakeTime(hour, minute)&#10;        &#10;        if (shouldBeAwake &amp;&amp; currentState != AppState.AWAKE) {&#10;            transitionToAwakeState()&#10;        } else if (!shouldBeAwake &amp;&amp; currentState == AppState.AWAKE) {&#10;            transitionToIdleState()&#10;        }&#10;    }&#10;    &#10;    private fun transitionToAwakeState() {&#10;        Log.d(TAG, &quot;Transitioning to AWAKE state&quot;)&#10;        currentState = AppState.AWAKE&#10;        &#10;        // Enable connectivity&#10;        connectivityManager.setAirplaneMode(false)&#10;        Thread.sleep(2000) // Wait for airplane mode to disable&#10;        connectivityManager.setMobileDataEnabled(true)&#10;        Thread.sleep(2000) // Wait for mobile data to enable&#10;        &#10;        // Connect to MQTT&#10;        mqttManager.connect()&#10;        &#10;        // Start GPS tracking&#10;        locationManager.startLocationUpdates()&#10;        &#10;        updateNotification(&quot;AWAKE - Tracking active&quot;)&#10;        broadcastStateUpdate()&#10;    }&#10;    &#10;    private fun transitionToIdleState() {&#10;        Log.d(TAG, &quot;Transitioning to IDLE state&quot;)&#10;        currentState = AppState.IDLE&#10;        &#10;        // Stop GPS tracking&#10;        locationManager.stopLocationUpdates()&#10;        &#10;        // Disconnect MQTT&#10;        mqttManager.disconnect()&#10;        &#10;        // Disable connectivity to save battery&#10;        connectivityManager.setMobileDataEnabled(false)&#10;        connectivityManager.setWifiEnabled(false)&#10;        connectivityManager.setAirplaneMode(true)&#10;        &#10;        updateNotification(&quot;IDLE - Power saving mode&quot;)&#10;        broadcastStateUpdate()&#10;    }&#10;    &#10;    private fun performBatteryCheck() {&#10;        Log.d(TAG, &quot;Performing battery check&quot;)&#10;        &#10;        val previousState = currentState&#10;        currentState = AppState.BATTERY_CHECK&#10;        &#10;        val batteryInfo = batteryMonitor.getBatteryInfo()&#10;        &#10;        // Try WiFi first, then mobile data&#10;        var networkEnabled = false&#10;        &#10;        if (connectivityManager.isWifiConnected()) {&#10;            networkEnabled = true&#10;        } else {&#10;            // Enable mobile data temporarily&#10;            connectivityManager.setAirplaneMode(false)&#10;            Thread.sleep(2000)&#10;            connectivityManager.setMobileDataEnabled(true)&#10;            Thread.sleep(3000) // Wait for connection&#10;            networkEnabled = true&#10;        }&#10;        &#10;        if (networkEnabled) {&#10;            // Connect to MQTT if not already connected&#10;            if (!mqttManager.isConnected()) {&#10;                mqttManager.connect()&#10;                Thread.sleep(3000) // Wait for MQTT connection&#10;            }&#10;            &#10;            // Send battery warning if below threshold&#10;            if (batteryInfo.level &lt;= AppConfig.BATTERY_LOW_THRESHOLD &amp;&amp; !batteryInfo.isCharging) {&#10;                mqttManager.publishBatteryWarning(batteryInfo.level, batteryInfo.isCharging)&#10;            }&#10;        }&#10;        &#10;        // Return to previous state&#10;        currentState = previousState&#10;        &#10;        // If was idle, disable network again&#10;        if (previousState == AppState.IDLE) {&#10;            mqttManager.disconnect()&#10;            connectivityManager.setMobileDataEnabled(false)&#10;            connectivityManager.setAirplaneMode(true)&#10;        }&#10;        &#10;        broadcastStateUpdate()&#10;    }&#10;    &#10;    private fun acquireWakeLock() {&#10;        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager&#10;        wakeLock = powerManager.newWakeLock(&#10;            PowerManager.PARTIAL_WAKE_LOCK,&#10;            &quot;GPSTracker::WakeLock&quot;&#10;        )&#10;        wakeLock?.acquire(24 * 60 * 60 * 1000L) // 24 hours&#10;        Log.d(TAG, &quot;WakeLock acquired&quot;)&#10;    }&#10;    &#10;    private fun releaseWakeLock() {&#10;        wakeLock?.let {&#10;            if (it.isHeld) {&#10;                it.release()&#10;                Log.d(TAG, &quot;WakeLock released&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;GPS Tracking Service&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;GPS tracking service notifications&quot;&#10;            }&#10;            &#10;            val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;    &#10;    private fun createNotification(contentText: String): Notification {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this,&#10;            0,&#10;            notificationIntent,&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;        &#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;GPS Tracker&quot;)&#10;            .setContentText(contentText)&#10;            .setSmallIcon(R.mipmap.ic_launcher)&#10;            .setContentIntent(pendingIntent)&#10;            .build()&#10;    }&#10;    &#10;    private fun updateNotification(contentText: String) {&#10;        val notification = createNotification(contentText)&#10;        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager&#10;        notificationManager.notify(NOTIFICATION_ID, notification)&#10;    }&#10;    &#10;    private fun broadcastStateUpdate() {&#10;        val intent = Intent(ACTION_STATE_UPDATE)&#10;        sendBroadcast(intent)&#10;    }&#10;    &#10;    fun getCurrentState(): AppState = currentState&#10;    &#10;    fun getStateInfo(): StateInfo {&#10;        val batteryInfo = batteryMonitor.getBatteryInfo()&#10;        return StateInfo(&#10;            state = currentState,&#10;            mqttConnected = mqttManager.isConnected(),&#10;            mqttBroker = mqttManager.getBrokerUrl(),&#10;            mqttClientId = mqttManager.getClientId(),&#10;            gpsTracking = locationManager.isTracking(),&#10;            batteryLevel = batteryInfo.level,&#10;            isCharging = batteryInfo.isCharging,&#10;            isDeviceOwner = connectivityManager.isDeviceOwner()&#10;        )&#10;    }&#10;    &#10;    data class StateInfo(&#10;        val state: AppState,&#10;        val mqttConnected: Boolean,&#10;        val mqttBroker: String,&#10;        val mqttClientId: String,&#10;        val gpsTracking: Boolean,&#10;        val batteryLevel: Int,&#10;        val isCharging: Boolean,&#10;        val isDeviceOwner: Boolean&#10;    )&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;GpsTrackingService&quot;&#10;        private const val CHANNEL_ID = &quot;gps_tracking_channel&quot;&#10;        private const val NOTIFICATION_ID = 1&#10;        const val ACTION_STATE_UPDATE = &quot;ovh.tenjo.gpstracker.STATE_UPDATE&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/utils/BatteryMonitor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/ovh/tenjo/gpstracker/utils/BatteryMonitor.kt" />
              <option name="updatedContent" value="package ovh.tenjo.gpstracker.utils&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.os.BatteryManager&#10;import android.util.Log&#10;&#10;class BatteryMonitor(private val context: Context) {&#10;    &#10;    fun getBatteryLevel(): Int {&#10;        val batteryStatus: Intent? = IntentFilter(Intent.ACTION_BATTERY_CHANGED).let { filter -&gt;&#10;            context.registerReceiver(null, filter)&#10;        }&#10;        &#10;        val level = batteryStatus?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1&#10;        val scale = batteryStatus?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1&#10;        &#10;        return if (level &gt;= 0 &amp;&amp; scale &gt; 0) {&#10;            (level.toFloat() / scale.toFloat() * 100).toInt()&#10;        } else {&#10;            -1&#10;        }&#10;    }&#10;    &#10;    fun isCharging(): Boolean {&#10;        val batteryStatus: Intent? = IntentFilter(Intent.ACTION_BATTERY_CHANGED).let { filter -&gt;&#10;            context.registerReceiver(null, filter)&#10;        }&#10;        &#10;        val status = batteryStatus?.getIntExtra(BatteryManager.EXTRA_STATUS, -1) ?: -1&#10;        return status == BatteryManager.BATTERY_STATUS_CHARGING ||&#10;               status == BatteryManager.BATTERY_STATUS_FULL&#10;    }&#10;    &#10;    fun getBatteryInfo(): BatteryInfo {&#10;        val level = getBatteryLevel()&#10;        val charging = isCharging()&#10;        &#10;        Log.d(TAG, &quot;Battery: $level%, Charging: $charging&quot;)&#10;        &#10;        return BatteryInfo(level, charging)&#10;    }&#10;    &#10;    data class BatteryInfo(&#10;        val level: Int,&#10;        val isCharging: Boolean&#10;    )&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;BatteryMonitor&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/device_admin.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/device_admin.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;device-admin xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;uses-policies&gt;&#10;        &lt;limit-password /&gt;&#10;        &lt;watch-login /&gt;&#10;        &lt;reset-password /&gt;&#10;        &lt;force-lock /&gt;&#10;        &lt;wipe-data /&gt;&#10;        &lt;expire-password /&gt;&#10;        &lt;encrypted-storage /&gt;&#10;        &lt;disable-camera /&gt;&#10;    &lt;/uses-policies&gt;&#10;&lt;/device-admin&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle/libs.versions.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle/libs.versions.toml" />
              <option name="originalContent" value="[versions]&#10;agp = &quot;8.13.1&quot;&#10;kotlin = &quot;2.0.21&quot;&#10;coreKtx = &quot;1.10.1&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.1.5&quot;&#10;espressoCore = &quot;3.7.0&quot;&#10;lifecycleRuntimeKtx = &quot;2.4.1&quot;&#10;activityCompose = &quot;1.8.0&quot;&#10;composeBom = &quot;2024.09.00&quot;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-compose-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-compose-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-compose-ui-tooling = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling&quot; }&#10;androidx-compose-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-compose-ui-test-manifest = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-manifest&quot; }&#10;androidx-compose-ui-test-junit4 = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-junit4&quot; }&#10;androidx-compose-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }&#10;kotlin-compose = { id = &quot;org.jetbrains.kotlin.plugin.compose&quot;, version.ref = &quot;kotlin&quot; }&#10;&#10;" />
              <option name="updatedContent" value="[versions]&#10;agp = &quot;8.13.1&quot;&#10;kotlin = &quot;2.0.21&quot;&#10;coreKtx = &quot;1.10.1&quot;&#10;junit = &quot;4.13.2&quot;&#10;junitVersion = &quot;1.1.5&quot;&#10;espressoCore = &quot;3.7.0&quot;&#10;lifecycleRuntimeKtx = &quot;2.4.1&quot;&#10;activityCompose = &quot;1.8.0&quot;&#10;composeBom = &quot;2024.09.00&quot;&#10;playServicesLocation = &quot;21.0.1&quot;&#10;mqttClient = &quot;1.2.5&quot;&#10;workRuntime = &quot;2.8.1&quot;&#10;&#10;[libraries]&#10;androidx-core-ktx = { group = &quot;androidx.core&quot;, name = &quot;core-ktx&quot;, version.ref = &quot;coreKtx&quot; }&#10;junit = { group = &quot;junit&quot;, name = &quot;junit&quot;, version.ref = &quot;junit&quot; }&#10;androidx-junit = { group = &quot;androidx.test.ext&quot;, name = &quot;junit&quot;, version.ref = &quot;junitVersion&quot; }&#10;androidx-espresso-core = { group = &quot;androidx.test.espresso&quot;, name = &quot;espresso-core&quot;, version.ref = &quot;espressoCore&quot; }&#10;androidx-lifecycle-runtime-ktx = { group = &quot;androidx.lifecycle&quot;, name = &quot;lifecycle-runtime-ktx&quot;, version.ref = &quot;lifecycleRuntimeKtx&quot; }&#10;androidx-activity-compose = { group = &quot;androidx.activity&quot;, name = &quot;activity-compose&quot;, version.ref = &quot;activityCompose&quot; }&#10;androidx-compose-bom = { group = &quot;androidx.compose&quot;, name = &quot;compose-bom&quot;, version.ref = &quot;composeBom&quot; }&#10;androidx-compose-ui = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui&quot; }&#10;androidx-compose-ui-graphics = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-graphics&quot; }&#10;androidx-compose-ui-tooling = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling&quot; }&#10;androidx-compose-ui-tooling-preview = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-tooling-preview&quot; }&#10;androidx-compose-ui-test-manifest = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-manifest&quot; }&#10;androidx-compose-ui-test-junit4 = { group = &quot;androidx.compose.ui&quot;, name = &quot;ui-test-junit4&quot; }&#10;androidx-compose-material3 = { group = &quot;androidx.compose.material3&quot;, name = &quot;material3&quot; }&#10;play-services-location = { group = &quot;com.google.android.gms&quot;, name = &quot;play-services-location&quot;, version.ref = &quot;playServicesLocation&quot; }&#10;mqtt-client = { group = &quot;org.eclipse.paho&quot;, name = &quot;org.eclipse.paho.client.mqttv3&quot;, version.ref = &quot;mqttClient&quot; }&#10;androidx-work-runtime-ktx = { group = &quot;androidx.work&quot;, name = &quot;work-runtime-ktx&quot;, version.ref = &quot;workRuntime&quot; }&#10;&#10;[plugins]&#10;android-application = { id = &quot;com.android.application&quot;, version.ref = &quot;agp&quot; }&#10;kotlin-android = { id = &quot;org.jetbrains.kotlin.android&quot;, version.ref = &quot;kotlin&quot; }&#10;kotlin-compose = { id = &quot;org.jetbrains.kotlin.plugin.compose&quot;, version.ref = &quot;kotlin&quot; }" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>